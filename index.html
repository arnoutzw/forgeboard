<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>ForgeBoard &mdash; Digital Whiteboard for Engineering</title>
<meta name="description" content="Engineering-focused digital whiteboard with vector shapes, freehand drawing, smart connectors and cross-tool integration.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%2318181b'/><path d='M8 24L16 8l8 16' stroke='%23f59e0b' stroke-width='2.5' fill='none' stroke-linecap='round' stroke-linejoin='round'/><circle cx='16' cy='16' r='3' fill='%23f59e0b'/></svg>">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiRm9yZ2VCb2FyZCIsInNob3J0X25hbWUiOiJGb3JnZUJvYXJkIiwic3RhcnRfdXJsIjoiLi8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMDkwOTBiIiwidGhlbWVfY29sb3IiOiIjZjU5ZTBiIn0=">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#09090b;--bg2:#18181b;--bg3:#27272a;--bg4:#3f3f46;--fg:#fafafa;--fg2:#a1a1aa;--fg3:#71717a;--accent:#f59e0b;--accent2:#d97706;--blue:#3b82f6;--green:#22c55e;--red:#ef4444;--purple:#8b5cf6;--pink:#ec4899;--cyan:#06b6d4;--font:'JetBrains Mono','SF Mono','Fira Code','Cascadia Code',monospace;--radius:6px;--shadow:0 4px 24px rgba(0,0,0,.4)}
[data-theme="light"]{--bg:#ffffff;--bg2:#f4f4f5;--bg3:#e4e4e7;--bg4:#d4d4d8;--fg:#09090b;--fg2:#52525b;--fg3:#71717a;--accent:#0066b2;--accent2:#004f8a;--shadow:0 4px 24px rgba(0,0,0,.1)}
[data-theme="eink"]{--bg:#ffffff;--bg2:#f5f5f5;--bg3:#e0e0e0;--bg4:#c0c0c0;--fg:#000000;--fg2:#333333;--fg3:#666666;--accent:#000000;--accent2:#333333;--shadow:none}
html,body{height:100%;overflow:hidden;font-family:var(--font);font-size:13px;background:var(--bg);color:var(--fg)}
button{font-family:inherit;font-size:inherit;cursor:pointer;border:none;background:none;color:inherit}
input,select,textarea{font-family:inherit;font-size:inherit;color:var(--fg);background:var(--bg3);border:1px solid var(--bg4);border-radius:var(--radius);padding:6px 10px;outline:none}
input:focus,select:focus,textarea:focus{border-color:var(--accent)}
::selection{background:var(--accent);color:var(--bg)}
::-webkit-scrollbar{width:6px;height:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--bg4);border-radius:3px}

/* Layout */
#app{display:flex;height:100vh;width:100vw;overflow:hidden}
#sidebar{width:56px;min-width:56px;background:var(--bg2);border-right:1px solid var(--bg3);display:flex;flex-direction:column;z-index:20;transition:width .2s}
#sidebar.expanded{width:240px}
#header{height:44px;min-height:44px;background:var(--bg2);border-bottom:1px solid var(--bg3);display:flex;align-items:center;padding:0 12px;gap:8px;z-index:15}
#main{flex:1;display:flex;flex-direction:column;overflow:hidden}
#canvas-wrap{flex:1;position:relative;overflow:hidden;background:var(--bg)}

/* Sidebar */
.sb-logo{height:48px;display:flex;align-items:center;justify-content:center;gap:8px;border-bottom:1px solid var(--bg3);padding:0 12px;flex-shrink:0}
.sb-logo svg{width:24px;height:24px;flex-shrink:0}
.sb-logo span{font-weight:700;font-size:14px;color:var(--accent);white-space:nowrap;overflow:hidden;display:none}
#sidebar.expanded .sb-logo span{display:block}
.sb-tools{flex:1;padding:6px;display:flex;flex-direction:column;gap:2px;overflow-y:auto}
.sb-tool{display:flex;align-items:center;gap:10px;padding:8px;border-radius:var(--radius);color:var(--fg2);transition:all .15s;position:relative;white-space:nowrap}
.sb-tool:hover{background:var(--bg3);color:var(--fg)}
.sb-tool.active{background:var(--accent);color:var(--bg)}
.sb-tool svg{width:18px;height:18px;flex-shrink:0}
.sb-tool span{display:none;font-size:12px}
#sidebar.expanded .sb-tool span{display:block}
.sb-sep{height:1px;background:var(--bg3);margin:4px 6px}
.sb-bottom{padding:6px;border-top:1px solid var(--bg3);flex-shrink:0}

/* Header */
.h-btn{display:flex;align-items:center;justify-content:center;width:32px;height:32px;border-radius:var(--radius);color:var(--fg2);transition:all .15s}
.h-btn:hover{background:var(--bg3);color:var(--fg)}
.h-btn.active{background:var(--accent);color:var(--bg)}
.h-btn svg{width:16px;height:16px}
.h-sep{width:1px;height:24px;background:var(--bg3)}
.h-title{font-weight:600;font-size:14px;margin-right:auto;cursor:pointer;padding:4px 8px;border-radius:var(--radius)}
.h-title:hover{background:var(--bg3)}
.zoom-display{font-size:11px;color:var(--fg2);min-width:44px;text-align:center}
.h-group{display:flex;align-items:center;gap:2px}

/* Canvas */
#svg-canvas{position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none}
#draw-canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;touch-action:none}
.grid-pattern{opacity:.15}
[data-theme="eink"] .grid-pattern{opacity:0}

/* Selection */
.selection-box{fill:rgba(245,158,11,.08);stroke:var(--accent);stroke-width:1;stroke-dasharray:4 4}
.element-handle{fill:var(--bg);stroke:var(--accent);stroke-width:1.5;cursor:pointer}
.connector-port{fill:var(--accent);stroke:var(--bg);stroke-width:2;opacity:0;transition:opacity .15s;cursor:crosshair}
.connector-port:hover{opacity:1 !important}

/* Minimap */
#minimap{position:absolute;bottom:12px;right:12px;width:160px;height:100px;background:var(--bg2);border:1px solid var(--bg3);border-radius:var(--radius);overflow:hidden;z-index:10;opacity:.85}
#minimap:hover{opacity:1}
.mm-viewport{fill:none;stroke:var(--accent);stroke-width:2}

/* Context menu */
.ctx-menu{position:fixed;background:var(--bg2);border:1px solid var(--bg3);border-radius:var(--radius);padding:4px;min-width:180px;box-shadow:var(--shadow);z-index:100;display:none}
.ctx-menu.show{display:block}
.ctx-item{display:flex;align-items:center;gap:8px;padding:6px 12px;border-radius:4px;font-size:12px;color:var(--fg2);cursor:pointer}
.ctx-item:hover{background:var(--bg3);color:var(--fg)}
.ctx-item.danger{color:var(--red)}
.ctx-item.danger:hover{background:rgba(239,68,68,.15)}
.ctx-sep{height:1px;background:var(--bg3);margin:4px 0}
.ctx-item .shortcut{margin-left:auto;opacity:.5;font-size:11px}

/* Modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:200;display:none;align-items:center;justify-content:center}
.modal-overlay.show{display:flex}
.modal{background:var(--bg2);border:1px solid var(--bg3);border-radius:12px;padding:24px;min-width:400px;max-width:520px;width:90%;box-shadow:var(--shadow)}
.modal h3{font-size:16px;margin-bottom:16px;color:var(--fg)}
.modal label{display:block;font-size:12px;color:var(--fg2);margin-bottom:4px;margin-top:12px}
.modal input,.modal select,.modal textarea{width:100%}
.modal textarea{resize:vertical;min-height:60px}
.modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:20px}
.btn{padding:8px 16px;border-radius:var(--radius);font-size:12px;font-weight:600;transition:all .15s}
.btn-primary{background:var(--accent);color:var(--bg)}
.btn-primary:hover{background:var(--accent2)}
.btn-ghost{color:var(--fg2)}
.btn-ghost:hover{background:var(--bg3);color:var(--fg)}
.btn-danger{background:var(--red);color:#fff}

/* Toast */
.toast-container{position:fixed;bottom:16px;right:16px;z-index:300;display:flex;flex-direction:column;gap:8px}
.toast{background:var(--bg2);border:1px solid var(--bg3);border-radius:var(--radius);padding:10px 16px;font-size:12px;color:var(--fg);box-shadow:var(--shadow);animation:toastIn .3s ease}
@keyframes toastIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}

/* Color palette */
.color-grid{display:flex;gap:4px;flex-wrap:wrap;margin-top:6px}
.color-swatch{width:24px;height:24px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:border-color .15s}
.color-swatch:hover,.color-swatch.active{border-color:var(--fg)}

/* Pen options panel */
#pen-panel,#shape-panel{display:none;position:absolute;left:68px;top:0;width:220px;height:100%;background:var(--bg2);border-right:1px solid var(--bg3);z-index:17;box-shadow:var(--shadow);overflow-y:auto;flex-direction:column;transition:left .2s}
#pen-panel.show,#shape-panel.show{display:flex}
.pp-section{padding:10px 14px;border-bottom:1px solid var(--bg3)}
.pp-section:last-child{border-bottom:none}
.pp-label{font-size:11px;color:var(--fg3);margin-bottom:6px;display:block;font-weight:500}
.pp-modes{display:flex;gap:2px}
.pp-mode{flex:1;padding:5px 0;border-radius:6px;font-size:11px;font-weight:600;text-align:center;color:var(--fg2);background:transparent;border:1px solid var(--bg3);cursor:pointer;transition:all .15s}
.pp-mode:hover{background:var(--bg3);color:var(--fg)}
.pp-mode.active{background:var(--accent);color:var(--bg);border-color:var(--accent)}
.pp-colors{display:flex;gap:4px;flex-wrap:wrap}
.pp-swatch{width:22px;height:22px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:border-color .15s}
.pp-swatch:hover,.pp-swatch.active{border-color:var(--fg)}
.pp-custom-color{width:22px;height:22px;border-radius:4px;border:1px dashed var(--bg4);cursor:pointer;padding:0;background:transparent}
.pp-slider-row{display:flex;align-items:center;gap:8px}
.pp-slider-row input[type="range"]{flex:1;accent-color:var(--accent)}
.pp-slider-val{font-size:11px;color:var(--fg2);min-width:28px;text-align:right;font-variant-numeric:tabular-nums}
.pp-preview-dot{display:flex;align-items:center;justify-content:center;height:24px}
.pp-preview-dot span{border-radius:50%;background:var(--fg)}
.pp-toggle{display:flex;align-items:center;gap:8px;font-size:12px;color:var(--fg2);cursor:pointer;margin-top:4px}
.pp-toggle:first-child{margin-top:0}
.pp-toggle input{accent-color:var(--accent)}
.pp-dash-options{display:flex;gap:4px}
.pp-dash-btn{flex:1;height:28px;border-radius:6px;border:1px solid var(--bg3);background:transparent;cursor:pointer;padding:4px 6px;display:flex;align-items:center;justify-content:center;transition:all .15s}
.pp-dash-btn:hover{background:var(--bg3)}
.pp-dash-btn.active{background:var(--accent);border-color:var(--accent)}
.pp-dash-btn svg{width:100%;height:4px}
.pp-dash-btn line{stroke:var(--fg2);stroke-width:2}
.pp-dash-btn.active line{stroke:var(--bg)}
#eraser-cursor{position:fixed;pointer-events:none;border:2px solid var(--fg2);border-radius:50%;z-index:30;display:none;transform:translate(-50%,-50%)}

/* Properties bar (bottom) */
#props-bar{height:0;overflow:hidden;background:var(--bg2);border-top:1px solid var(--bg3);transition:height .2s;padding:0 12px;display:flex;align-items:center;gap:12px;flex-shrink:0}
#props-bar.show{height:40px}
.prop-group{display:flex;align-items:center;gap:4px}
.prop-label{font-size:11px;color:var(--fg3);white-space:nowrap}
.prop-input{width:60px;padding:3px 6px;font-size:11px}
.prop-color{width:24px;height:24px;border-radius:4px;border:1px solid var(--bg4);cursor:pointer;padding:0}

/* Demo banner */
#demo-banner{display:none;background:linear-gradient(90deg,var(--accent),var(--accent2));color:var(--bg);text-align:center;padding:6px 12px;font-size:12px;font-weight:600;z-index:25;flex-shrink:0}
#demo-banner.show{display:flex;align-items:center;justify-content:center;gap:12px}
#demo-banner button{background:rgba(0,0,0,.2);color:inherit;padding:3px 10px;border-radius:4px;font-size:11px;font-weight:600}
#demo-banner button:hover{background:rgba(0,0,0,.35)}

/* Board list */
.board-list{padding:6px}
.board-item{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:var(--radius);cursor:pointer;font-size:12px;color:var(--fg2)}
.board-item:hover{background:var(--bg3);color:var(--fg)}
.board-item.active{background:var(--accent);color:var(--bg)}
.board-item svg{width:14px;height:14px;flex-shrink:0}

/* Tablet mode */
@media(max-width:1023px),(pointer:coarse){
  #sidebar{display:none}
  #tablet-toolbar{display:flex !important}
  #minimap{width:120px;height:75px;bottom:72px}
}
#tablet-toolbar{display:none;position:fixed;bottom:0;left:0;right:0;height:56px;background:var(--bg2);border-top:1px solid var(--bg3);z-index:20;align-items:center;justify-content:center;gap:4px;padding:0 8px;overflow-x:auto}
.tb-tool{display:flex;flex-direction:column;align-items:center;justify-content:center;min-width:48px;height:48px;border-radius:var(--radius);color:var(--fg2);font-size:9px;gap:2px}
.tb-tool:hover,.tb-tool.active{background:var(--accent);color:var(--bg)}
.tb-tool svg{width:20px;height:20px}

/* SSO */
.user-avatar{width:28px;height:28px;border-radius:50%;background:var(--accent);display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700;color:var(--bg);flex-shrink:0}

/* Layers panel */
#layers-panel{display:none;position:absolute;right:12px;top:56px;width:220px;background:var(--bg2);border:1px solid var(--bg3);border-radius:var(--radius);z-index:30;box-shadow:var(--shadow);max-height:300px;overflow-y:auto}
#layers-panel.show{display:block}
.lp-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid var(--bg3);font-size:12px;font-weight:600}
.lp-layer{display:flex;align-items:center;gap:6px;padding:6px 12px;font-size:12px;color:var(--fg2);cursor:pointer;border-bottom:1px solid var(--bg3)}
.lp-layer:hover{background:var(--bg3)}
.lp-layer.active{background:rgba(245,158,11,.1);color:var(--fg)}
.lp-layer .lp-name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.lp-icon{width:16px;height:16px;display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:.6}
.lp-icon:hover{opacity:1}
.lp-icon.off{opacity:.25}
.lp-icon svg{width:14px;height:14px}

/* Symbol library panel */
#symbol-panel{display:none;position:absolute;left:68px;top:0;width:280px;min-width:180px;max-width:50vw;height:100%;background:var(--bg2);border-right:1px solid var(--bg3);z-index:18;box-shadow:var(--shadow);overflow:hidden;flex-direction:column;transition:left .2s}
#sidebar.expanded ~ #pen-panel,#sidebar.expanded ~ #shape-panel{left:252px}
#sidebar.expanded ~ #symbol-panel{left:252px}
.panel-resize-handle{position:absolute;right:0;top:0;width:5px;height:100%;cursor:col-resize;z-index:19;background:transparent;transition:background .15s}.panel-resize-handle:hover,.panel-resize-handle.active{background:var(--accent)}
#symbol-panel.show{display:flex}
.sp-header{padding:12px;border-bottom:1px solid var(--bg3)}
.sp-header h4{font-size:13px;font-weight:600;margin-bottom:8px}
.sp-search{width:100%;padding:6px 10px;font-size:12px}
.sp-tabs{display:flex;gap:2px;padding:8px 12px;border-bottom:1px solid var(--bg3);overflow-x:auto}
.sp-tab{padding:4px 10px;border-radius:4px;font-size:11px;color:var(--fg2);white-space:nowrap;cursor:pointer}
.sp-tab:hover{background:var(--bg3)}
.sp-tab.active{background:var(--accent);color:var(--bg)}
.sp-grid{flex:1;overflow-y:auto;padding:8px;display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
.sp-item{display:flex;flex-direction:column;align-items:center;gap:4px;padding:8px 4px;border-radius:var(--radius);cursor:grab;border:1px solid transparent;transition:all .15s}
.sp-item:hover{background:var(--bg3);border-color:var(--bg4)}
.sp-item svg{width:40px;height:40px}
.sp-item span{font-size:9px;color:var(--fg3);text-align:center;line-height:1.2;max-height:22px;overflow:hidden}

/* Lasso selection path */
.lasso-path{fill:rgba(245,158,11,.05);stroke:var(--accent);stroke-width:1.5;stroke-dasharray:5 3;pointer-events:none}
</style>
<script>
// BSI Theme Bridge v1.1 — iframe: parent-only control / standalone: local toggle
(function() {
  var APP_THEME_KEY = 'fb_theme';
  var isEmbedded = (window.parent !== window);
  function applyBsiTheme(theme) {
    if (theme !== 'dark' && theme !== 'light') theme = 'dark';
    var html = document.documentElement;
    html.setAttribute('data-theme', theme);
    html.style.colorScheme = theme;
    var meta = document.querySelector('meta[name="theme-color"]');
    if (meta) meta.content = (theme === 'light') ? '#ffffff' : '#09090b';
    document.dispatchEvent(new CustomEvent('bsi-theme-applied', { detail: { theme: theme } }));
  }
  function mapTheme(raw) {
    return (raw === 'asml' || raw === 'light') ? 'light' : 'dark';
  }
  if (isEmbedded) {
    var s = document.createElement('style');
    s.textContent = '[data-theme-toggle]{display:none!important}';
    (document.head || document.documentElement).appendChild(s);
    window.addEventListener('message', function(e) {
      if (e.data && e.data.type === 'theme-change') applyBsiTheme(mapTheme(e.data.theme));
    });
    applyBsiTheme('dark');
    try { window.parent.postMessage({ type: 'theme-request' }, '*'); } catch(e) {}
  } else {
    var saved = localStorage.getItem(APP_THEME_KEY) || 'dark';
    if (saved === 'asml') { saved = 'light'; localStorage.setItem(APP_THEME_KEY, saved); }
    applyBsiTheme(saved);
    window.bsiToggleTheme = function() {
      var next = (document.documentElement.getAttribute('data-theme') || 'dark') === 'dark' ? 'light' : 'dark';
      applyBsiTheme(next);
      localStorage.setItem(APP_THEME_KEY, next);
    };
    window.bsiSetTheme = function(theme) {
      var mapped = mapTheme(theme);
      applyBsiTheme(mapped);
      localStorage.setItem(APP_THEME_KEY, mapped);
    };
  }
  window._bsiIsEmbedded = isEmbedded;
  window._bsiApplyTheme = applyBsiTheme;
})();
</script>
</head>
<body>
<div id="app">
  <!-- Demo banner -->
  <div id="demo-banner"><span>Demo Mode — sample data loaded</span><button onclick="app.resetDemo()">Reset Data</button><button onclick="app.exitDemo()">Exit Demo</button></div>

  <!-- Sidebar -->
  <div id="sidebar">
    <div class="sb-logo">
      <svg viewBox="0 0 32 32" fill="none"><rect width="32" height="32" rx="6" fill="var(--accent)"/><path d="M8 24L16 8l8 16" stroke="var(--bg)" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="16" r="3" fill="var(--bg)"/></svg>
      <span>ForgeBoard</span>
    </div>
    <div class="sb-tools" id="tool-list"></div>
    <div class="sb-sep"></div>
    <div class="sb-bottom">
      <button class="sb-tool" onclick="app.toggleSidebar()" title="Toggle sidebar">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 3H3v18h18V3zM9 3v18"/></svg>
        <span>Collapse</span>
      </button>
    </div>
  </div>

  <!-- Pen options panel -->
  <div id="pen-panel">
    <div class="pp-section" id="pp-draw-options">
      <span class="pp-label">Mode</span>
      <div class="pp-modes">
        <button class="pp-mode active" data-mode="pen" onclick="app.setPenMode('pen')">Pen</button>
        <button class="pp-mode" data-mode="marker" onclick="app.setPenMode('marker')">Marker</button>
        <button class="pp-mode" data-mode="highlighter" onclick="app.setPenMode('highlighter')">Highlight</button>
      </div>
    </div>
    <div class="pp-section" id="pp-color-section">
      <span class="pp-label">Color</span>
      <div class="pp-colors" id="pp-color-grid"></div>
    </div>
    <div class="pp-section" id="pp-width-section">
      <span class="pp-label">Width</span>
      <div class="pp-preview-dot"><span id="pp-width-dot"></span></div>
      <div class="pp-slider-row">
        <input type="range" id="pp-width" min="1" max="20" value="3" oninput="app.setPenWidth(+this.value)">
        <span class="pp-slider-val" id="pp-width-val">3px</span>
      </div>
    </div>
    <div class="pp-section" id="pp-opacity-section">
      <span class="pp-label">Opacity</span>
      <div class="pp-slider-row">
        <input type="range" id="pp-opacity" min="5" max="100" value="100" oninput="app.setPenOpacity(+this.value/100)">
        <span class="pp-slider-val" id="pp-opacity-val">100%</span>
      </div>
    </div>
    <div class="pp-section" id="pp-toggles">
      <label class="pp-toggle"><input type="checkbox" id="pp-pressure" checked onchange="app.togglePressure()"> Pressure</label>
      <label class="pp-toggle"><input type="checkbox" id="pp-smoothing" checked onchange="app.toggleSmoothing()"> Smoothing</label>
    </div>
    <div class="pp-section" id="pp-eraser-section" style="display:none">
      <span class="pp-label">Eraser Size</span>
      <div class="pp-slider-row">
        <input type="range" id="pp-eraser-radius" min="5" max="80" value="20" oninput="app.setEraserRadius(+this.value)">
        <span class="pp-slider-val" id="pp-eraser-val">20px</span>
      </div>
    </div>
  </div>

  <!-- Shape options panel -->
  <div id="shape-panel">
    <div class="pp-section">
      <span class="pp-label">Fill</span>
      <div class="pp-colors" id="sp-fill-grid"></div>
    </div>
    <div class="pp-section">
      <span class="pp-label">Stroke</span>
      <div class="pp-colors" id="sp-stroke-grid"></div>
    </div>
    <div class="pp-section">
      <span class="pp-label">Stroke Width</span>
      <div class="pp-slider-row">
        <input type="range" id="sp-stroke-width" min="0" max="8" value="2" oninput="app.setShapeStrokeWidth(+this.value)">
        <span class="pp-slider-val" id="sp-stroke-width-val">2px</span>
      </div>
    </div>
    <div class="pp-section">
      <span class="pp-label">Line Style</span>
      <div class="pp-dash-options" id="sp-dash-options">
        <button class="pp-dash-btn active" data-dash="" onclick="app.setShapeStrokeDash('')" title="Solid">
          <svg viewBox="0 0 40 4"><line x1="0" y1="2" x2="40" y2="2"/></svg>
        </button>
        <button class="pp-dash-btn" data-dash="8 4" onclick="app.setShapeStrokeDash('8 4')" title="Dashed">
          <svg viewBox="0 0 40 4"><line x1="0" y1="2" x2="40" y2="2" stroke-dasharray="8 4"/></svg>
        </button>
        <button class="pp-dash-btn" data-dash="3 3" onclick="app.setShapeStrokeDash('3 3')" title="Dotted">
          <svg viewBox="0 0 40 4"><line x1="0" y1="2" x2="40" y2="2" stroke-dasharray="3 3"/></svg>
        </button>
        <button class="pp-dash-btn" data-dash="12 4 3 4" onclick="app.setShapeStrokeDash('12 4 3 4')" title="Dash-dot">
          <svg viewBox="0 0 40 4"><line x1="0" y1="2" x2="40" y2="2" stroke-dasharray="12 4 3 4"/></svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Symbol library panel -->
  <div id="symbol-panel">
    <div class="sp-header"><h4>Engineering Symbols</h4><input class="sp-search" id="symbol-search" placeholder="Search symbols..." oninput="app.filterSymbols(this.value)"></div>
    <div class="sp-tabs" id="symbol-tabs"></div>
    <div class="sp-grid" id="symbol-grid"></div>
    <div class="panel-resize-handle" id="symbol-resize"></div>
  </div>

  <!-- Main -->
  <div id="main">
    <div id="header">
      <button class="h-btn" onclick="app.toggleSidebar()" title="Toggle sidebar">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h18M3 6h18M3 18h18"/></svg>
      </button>
      <span class="h-title" id="board-name" onclick="app.renameBoard()">Untitled Board</span>
      <div class="h-group">
        <button class="h-btn" onclick="app.zoomIn()" title="Zoom in"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button>
        <span class="zoom-display" id="zoom-display">100%</span>
        <button class="h-btn" onclick="app.zoomOut()" title="Zoom out"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/></svg></button>
        <button class="h-btn" onclick="app.fitToScreen()" title="Fit to screen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 3v18M3 15h18"/></svg></button>
      </div>
      <div class="h-sep"></div>
      <div class="h-group">
        <button class="h-btn" onclick="app.undo()" title="Undo (Ctrl+Z)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M3 13a9 9 0 0 1 15-6.7L21 9"/></svg></button>
        <button class="h-btn" onclick="app.redo()" title="Redo (Ctrl+Shift+Z)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 7v6h-6"/><path d="M21 13a9 9 0 0 0-15-6.7L3 9"/></svg></button>
      </div>
      <div class="h-sep"></div>
      <div class="h-group">
        <button class="h-btn" onclick="app.exportJSON()" title="Export JSON"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M7 10l5 5 5-5"/><path d="M12 15V3"/></svg></button>
        <button class="h-btn" onclick="app.importJSON()" title="Import JSON"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M17 8l-5-5-5 5"/><path d="M12 3v12"/></svg></button>
        <button class="h-btn" onclick="app.exportPNG()" title="Export PNG"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg></button>
      </div>
      <div class="h-sep"></div>
      <button class="h-btn" onclick="app.toggleLayers()" title="Layers" id="layers-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></button>
      <button class="h-btn" data-theme-toggle onclick="app.toggleTheme()" title="Toggle theme" id="theme-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"/></svg>
      </button>
      <div class="user-avatar" id="user-avatar">A</div>
    </div>

    <!-- Canvas -->
    <div id="canvas-wrap">
      <svg id="svg-canvas" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <pattern id="grid-dots" width="20" height="20" patternUnits="userSpaceOnUse">
            <circle cx="10" cy="10" r="0.8" fill="var(--fg3)" class="grid-pattern"/>
          </pattern>
          <marker id="arrow-end" markerWidth="10" markerHeight="8" refX="9" refY="4" orient="auto">
            <path d="M0 0L10 4L0 8z" fill="var(--fg2)"/>
          </marker>
          <marker id="arrow-end-accent" markerWidth="10" markerHeight="8" refX="9" refY="4" orient="auto">
            <path d="M0 0L10 4L0 8z" fill="var(--accent)"/>
          </marker>
        </defs>
        <g id="canvas-grid"><rect width="99999" height="99999" x="-49999" y="-49999" fill="url(#grid-dots)"/></g>
        <g id="canvas-elements"></g>
        <g id="canvas-connectors"></g>
        <g id="canvas-overlay"></g>
        <g id="canvas-selection"></g>
      </svg>
      <canvas id="draw-canvas"></canvas>
      <div id="minimap"><svg id="minimap-svg" viewBox="0 0 160 100"></svg></div>
      <!-- Layers panel -->
      <div id="layers-panel">
        <div class="lp-header"><span>Layers</span><button class="h-btn" onclick="app.addLayer()" title="Add layer" style="width:22px;height:22px"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button></div>
        <div id="layers-list"></div>
      </div>
    </div>

    <!-- Properties bar -->
    <div id="props-bar">
      <div class="prop-group" id="pg-fill">
        <span class="prop-label">Fill</span>
        <input type="color" class="prop-color" id="prop-fill" value="#292524" onchange="app.setProp('fill',this.value)">
      </div>
      <div class="prop-group" id="pg-stroke">
        <span class="prop-label">Stroke</span>
        <input type="color" class="prop-color" id="prop-stroke" value="#f59e0b" onchange="app.setProp('stroke',this.value)">
      </div>
      <div class="prop-group" id="pg-stroke-width">
        <span class="prop-label">Width</span>
        <input type="number" class="prop-input" id="prop-stroke-width" value="2" min="0" max="20" onchange="app.setProp('strokeWidth',+this.value)">
      </div>
      <div class="prop-group" id="pg-font-size">
        <span class="prop-label">Font</span>
        <input type="number" class="prop-input" id="prop-font-size" value="14" min="8" max="72" onchange="app.setProp('fontSize',+this.value)">
      </div>
      <div class="prop-group" id="pg-icon-size">
        <span class="prop-label">Icon</span>
        <input type="range" style="width:80px" id="prop-icon-scale" min="0.5" max="2" step="0.1" value="1" oninput="app.setProp('iconScale',+this.value)">
        <span class="prop-label" id="prop-icon-scale-val" style="min-width:28px">1×</span>
      </div>
      <div class="prop-group" id="pg-opacity">
        <span class="prop-label">Opacity</span>
        <input type="range" style="width:80px" id="prop-opacity" min="0" max="1" step="0.05" value="1" oninput="app.setProp('opacity',+this.value)">
      </div>
    </div>
  </div>
</div>

<!-- Tablet toolbar -->
<div id="tablet-toolbar"></div>

<!-- Context menu -->
<div class="ctx-menu" id="ctx-menu"></div>

<!-- Element edit modal -->
<div class="modal-overlay" id="modal-edit">
  <div class="modal">
    <h3>Edit Element</h3>
    <label>Text</label>
    <textarea id="edit-text" rows="3"></textarea>
    <label>Type</label>
    <select id="edit-type">
      <option value="rectangle">Rectangle</option>
      <option value="ellipse">Ellipse</option>
      <option value="diamond">Diamond</option>
      <option value="text">Text</option>
      <option value="sticky">Sticky Note</option>
      <option value="engineering-block">Engineering Block</option>
    </select>
    <div style="display:flex;gap:12px">
      <div style="flex:1"><label>Fill Color</label><input type="color" id="edit-fill" value="#292524"></div>
      <div style="flex:1"><label>Stroke Color</label><input type="color" id="edit-stroke" value="#f59e0b"></div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-ghost" onclick="app.closeModal('modal-edit')">Cancel</button>
      <button class="btn btn-primary" onclick="app.saveEdit()">Save</button>
    </div>
  </div>
</div>

<!-- New board modal -->
<div class="modal-overlay" id="modal-new-board">
  <div class="modal">
    <h3>New Board</h3>
    <label>Board Name</label>
    <input id="new-board-name" placeholder="Untitled Board">
    <label>Template</label>
    <select id="new-board-template">
      <option value="blank">Blank Canvas</option>
      <option value="block-diagram">System Block Diagram</option>
      <option value="fishbone">Fishbone / Ishikawa</option>
      <option value="retrospective">Sprint Retrospective</option>
      <option value="kanban">Kanban Flow</option>
    </select>
    <div class="modal-actions">
      <button class="btn btn-ghost" onclick="app.closeModal('modal-new-board')">Cancel</button>
      <button class="btn btn-primary" onclick="app.createNewBoard()">Create</button>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-container" id="toasts"></div>
<div id="eraser-cursor"></div>

<!-- Hidden file input -->
<input type="file" id="file-input" accept=".json" style="display:none" onchange="app.handleImport(event)">

<script>
/* =========================================================================
   ForgeBoard — Digital Whiteboard for Engineering Teams
   Single-file vanilla JS application
   ========================================================================= */

const SVG_NS = 'http://www.w3.org/2000/svg';

// ─── Utility helpers ─────────────────────────────────────────────
function uid() { return 'el-' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function dist(a, b) { return Math.hypot(b.x - a.x, b.y - a.y); }
function lerp(a, b, t) { return a + (b - a) * t; }
function smoothPoints(pts, tension) {
  if (!tension) tension = 0.5;
  if (pts.length < 3) return pts;
  const out = [pts[0]];
  for (let i = 0; i < pts.length - 1; i++) {
    const p0 = pts[Math.max(0, i - 1)];
    const p1 = pts[i];
    const p2 = pts[Math.min(pts.length - 1, i + 1)];
    const p3 = pts[Math.min(pts.length - 1, i + 2)];
    const steps = 4;
    for (let s = 1; s <= steps; s++) {
      const t = s / steps;
      const t2 = t * t, t3 = t2 * t;
      const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t * tension +
        (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 * tension +
        (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3 * tension);
      const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t * tension +
        (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 * tension +
        (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3 * tension);
      const pr = lerp(p1.pressure || 0.5, p2.pressure || 0.5, t);
      out.push({ x, y, pressure: pr });
    }
  }
  return out;
}

// ─── Tool definitions ────────────────────────────────────────────
const TOOLS = [
  { id: 'select', label: 'Select', key: 'V', icon: '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/>' },
  { id: 'pan', label: 'Pan', key: 'H', icon: '<path d="M18 11V6a2 2 0 0 0-4 0v5"/><path d="M14 10V4a2 2 0 0 0-4 0v6"/><path d="M10 9.5V4a2 2 0 0 0-4 0v10"/><path d="M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.9-5.7-2.4L3.7 16a2 2 0 0 1 3.1-2.5L10 17"/>' },
  { id: 'pen', label: 'Pen', key: 'P', icon: '<path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/>' },
  { sep: true },
  { id: 'rectangle', label: 'Rectangle', key: 'R', icon: '<rect x="3" y="3" width="18" height="18" rx="2"/>' },
  { id: 'ellipse', label: 'Ellipse', key: 'O', icon: '<ellipse cx="12" cy="12" rx="10" ry="8"/>' },
  { id: 'diamond', label: 'Diamond', key: 'D', icon: '<path d="M12 2l10 10-10 10L2 12z"/>' },
  { sep: true },
  { id: 'line', label: 'Line', key: 'L', icon: '<path d="M5 19L19 5"/>' },
  { id: 'arrow', label: 'Arrow', key: 'A', icon: '<path d="M5 12h14"/><path d="M12 5l7 7-7 7"/>' },
  { id: 'connector', label: 'Connector', key: 'C', icon: '<circle cx="5" cy="12" r="2"/><circle cx="19" cy="12" r="2"/><path d="M7 12h4a2 2 0 0 1 2 2v0a2 2 0 0 0 2 2h2"/>' },
  { sep: true },
  { id: 'text', label: 'Text', key: 'T', icon: '<path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/>' },
  { id: 'sticky', label: 'Sticky', key: 'S', icon: '<path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8z"/><path d="M15 3v6h6"/>' },
  { sep: true },
  { id: 'eraser', label: 'Eraser', key: 'E', icon: '<path d="M7 21h10"/><path d="M5.5 13.5L12 7l5 5-6.5 6.5a2.12 2.12 0 0 1-3 0L5.5 16.5a2.12 2.12 0 0 1 0-3z"/>' },
  { sep: true },
  { id: 'lasso', label: 'Lasso', key: 'Q', icon: '<path d="M12 22c5.52 0 10-4.48 10-10S17.52 2 12 2 2 6.48 2 12s4.48 10 10 10z" stroke-dasharray="4 3"/><path d="M12 22v-4"/>' },
  { id: 'symbol', label: 'Symbols', key: 'G', icon: '<circle cx="12" cy="6" r="3"/><path d="M6 18v-2a6 6 0 0 1 4-5.66"/><path d="M14 12.34A6 6 0 0 1 18 18v0"/><path d="M16 12h6"/><path d="M19 9v6"/>' },
];

const STICKY_COLORS = ['#fbbf24','#34d399','#60a5fa','#f87171','#c084fc','#f472b6','#22d3ee'];
const SHAPE_FILLS = ['#292524','#1e3a5f','#1a332a','#3b1a1a','#2d1b4e','transparent'];
const STROKE_COLORS = ['#f59e0b','#3b82f6','#22c55e','#ef4444','#8b5cf6','#ec4899','#71717a','#ffffff'];

// ─── Main Application ────────────────────────────────────────────
const app = {
  // State
  boards: [],
  activeBoardId: null,
  tool: 'select',
  elements: [],
  undoStack: [],
  redoStack: [],
  viewport: { x: 0, y: 0, zoom: 1 },
  gridSize: 20,
  snapToGrid: true,
  selection: [],
  dragging: null,
  resizing: null,
  drawing: null,
  connecting: null,
  rubberBand: null,
  penPressure: true,
  penWidth: 3,
  penColor: '#f59e0b',
  penOpacity: 1,
  penMode: 'pen',
  penSmoothing: true,
  eraserRadius: 20,
  shapeFill: null,
  shapeStroke: null,
  shapeStrokeWidth: 2,
  shapeStrokeDash: '',
  isDemo: false,
  sidebarExpanded: false,
  theme: 'dark',
  ssoUser: null,

  // ─── Init ────────────────────────────────────────────────
  init() {
    this.isDemo = new URLSearchParams(location.search).has('demo');
    this.detectTheme();
    this.setupSSO();
    document.addEventListener('bsi-theme-applied', (e) => {
      if (e.detail && e.detail.theme) { this.theme = e.detail.theme; this.render(); }
    });
    this.loadData();
    this.buildTools();
    this.buildTabletToolbar();
    this.buildPenPanel();
    this.buildShapePanel();
    this.bindEvents();
    this.detectEink();
    this.initSymbolPanel();
    this.initPanelResize();
    this.resizeCanvas();
    this.render();
    if (this.isDemo) {
      document.getElementById('demo-banner').classList.add('show');
      if (this.boards.length === 0) this.loadDemoData();
    }
    if (this.boards.length === 0) {
      this.boards.push(this.makeBoard('Untitled Board'));
      this.activeBoardId = this.boards[0].id;
    }
    if (!this.activeBoardId) this.activeBoardId = this.boards[0].id;
    this.switchBoard(this.activeBoardId);
  },

  detectTheme() {
    // Detect Boox e-ink
    const ua = navigator.userAgent || '';
    if (ua.includes('BOOX') || window.matchMedia('(update: slow)').matches) {
      this.theme = 'eink';
      document.documentElement.setAttribute('data-theme', 'eink');
    } else {
      this.theme = document.documentElement.getAttribute('data-theme') || 'dark';
    }
  },

  setupSSO() {
    window.addEventListener('message', (e) => {
      if (e.data && e.data.type === 'sso-user') {
        this.ssoUser = e.data.user;
        const av = document.getElementById('user-avatar');
        if (av && this.ssoUser) av.textContent = (this.ssoUser.name || 'U')[0].toUpperCase();
      }
    });
    // Theme sync handled by BSI Theme Bridge v1.1 in <head>
  },

  // ─── Data persistence ────────────────────────────────────
  storageKey(k) { return (this.isDemo ? 'demo_db_forgeboard_' : 'forgeboard_') + k; },

  loadData() {
    try {
      const raw = localStorage.getItem(this.storageKey('boards'));
      if (raw) {
        const d = JSON.parse(raw);
        this.boards = d.boards || [];
        this.activeBoardId = d.activeBoardId || (this.boards[0] && this.boards[0].id);
      }
    } catch(e) { console.warn('Failed to load data', e); }
  },

  saveData() {
    clearTimeout(this._saveTimer);
    this._saveTimer = setTimeout(() => {
      // Sync current board state
      const b = this.getActiveBoard();
      if (b) {
        b.elements = JSON.parse(JSON.stringify(this.elements));
        b.viewport = { ...this.viewport };
        b.modified = new Date().toISOString();
      }
      try {
        localStorage.setItem(this.storageKey('boards'), JSON.stringify({
          boards: this.boards,
          activeBoardId: this.activeBoardId
        }));
      } catch(e) { console.warn('Save failed', e); }
    }, 500);
  },

  makeBoard(name, elements = []) {
    return {
      id: uid(),
      name,
      created: new Date().toISOString(),
      modified: new Date().toISOString(),
      elements: elements,
      viewport: { x: 0, y: 0, zoom: 1 },
    };
  },

  getActiveBoard() { return this.boards.find(b => b.id === this.activeBoardId); },

  switchBoard(id) {
    // Save current board
    const cur = this.getActiveBoard();
    if (cur) {
      cur.elements = JSON.parse(JSON.stringify(this.elements));
      cur.viewport = { ...this.viewport };
    }
    this.activeBoardId = id;
    const b = this.getActiveBoard();
    if (b) {
      this.elements = JSON.parse(JSON.stringify(b.elements || []));
      this.viewport = { ...b.viewport };
      document.getElementById('board-name').textContent = b.name;
    }
    this.selection = [];
    this.undoStack = [];
    this.redoStack = [];
    this.render();
    this.saveData();
  },

  // ─── Tool building ───────────────────────────────────────
  buildTools() {
    const list = document.getElementById('tool-list');
    TOOLS.forEach(t => {
      if (t.sep) { const s = document.createElement('div'); s.className = 'sb-sep'; list.appendChild(s); return; }
      const btn = document.createElement('button');
      btn.className = 'sb-tool' + (t.id === this.tool ? ' active' : '');
      btn.dataset.tool = t.id;
      btn.title = `${t.label} (${t.key})`;
      btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${t.icon}</svg><span>${t.label}</span>`;
      btn.onclick = () => this.setTool(t.id);
      list.appendChild(btn);
    });
  },

  buildTabletToolbar() {
    const bar = document.getElementById('tablet-toolbar');
    TOOLS.forEach(t => {
      if (t.sep) return;
      const btn = document.createElement('button');
      btn.className = 'tb-tool' + (t.id === this.tool ? ' active' : '');
      btn.dataset.tool = t.id;
      btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${t.icon}</svg>${t.label}`;
      btn.onclick = () => this.setTool(t.id);
      bar.appendChild(btn);
    });
  },

  setTool(id) {
    if (id === 'symbol') { this.toggleSymbolPanel(); return; }
    // Hide symbol panel when switching away
    document.getElementById('symbol-panel').classList.remove('show');
    this.tool = id;
    document.querySelectorAll('.sb-tool[data-tool],.tb-tool[data-tool]').forEach(b => {
      b.classList.toggle('active', b.dataset.tool === id);
    });
    const wrap = document.getElementById('canvas-wrap');
    wrap.style.cursor = id === 'eraser' ? 'none' : id === 'pan' ? 'grab' : id === 'pen' || id === 'lasso' ? 'crosshair' : id === 'select' ? 'default' : 'crosshair';
    document.getElementById('draw-canvas').style.cursor = id === 'eraser' ? 'none' : '';
    if (id !== 'eraser') document.getElementById('eraser-cursor').style.display = 'none';
    // Show/hide draw canvas
    document.getElementById('draw-canvas').style.pointerEvents = (id === 'pen' || id === 'eraser') ? 'auto' : 'none';
    // Show/hide pen panel
    if (id === 'pen' || id === 'eraser') { this.showPenPanel(id); this.hideShapePanel(); }
    else if (['rectangle','ellipse','diamond','line','arrow','connector'].includes(id)) { this.showShapePanel(); this.hidePenPanel(); }
    else { this.hidePenPanel(); this.hideShapePanel(); }
  },

  // ─── Pen options panel ──────────────────────────────────
  buildPenPanel() {
    const grid = document.getElementById('pp-color-grid');
    STROKE_COLORS.forEach(c => {
      const sw = document.createElement('div');
      sw.className = 'pp-swatch' + (c === this.penColor ? ' active' : '');
      sw.style.background = c;
      sw.onclick = () => this.setPenColor(c);
      grid.appendChild(sw);
    });
    // Custom color picker
    const custom = document.createElement('input');
    custom.type = 'color';
    custom.className = 'pp-custom-color';
    custom.value = this.penColor;
    custom.title = 'Custom color';
    custom.oninput = () => this.setPenColor(custom.value);
    grid.appendChild(custom);
    this.updateWidthDot();
  },

  showPenPanel(toolId) {
    const panel = document.getElementById('pen-panel');
    const drawOpts = document.getElementById('pp-draw-options');
    const colorSec = document.getElementById('pp-color-section');
    const widthSec = document.getElementById('pp-width-section');
    const opacitySec = document.getElementById('pp-opacity-section');
    const toggleSec = document.getElementById('pp-toggles');
    const eraserSec = document.getElementById('pp-eraser-section');
    const isEraser = toolId === 'eraser';
    drawOpts.style.display = isEraser ? 'none' : '';
    colorSec.style.display = isEraser ? 'none' : '';
    widthSec.style.display = isEraser ? 'none' : '';
    opacitySec.style.display = isEraser ? 'none' : '';
    toggleSec.style.display = isEraser ? 'none' : '';
    eraserSec.style.display = isEraser ? '' : 'none';
    // Sync controls to current state
    document.getElementById('pp-width').value = this.penWidth;
    document.getElementById('pp-width-val').textContent = this.penWidth + 'px';
    document.getElementById('pp-opacity').value = Math.round(this.penOpacity * 100);
    document.getElementById('pp-opacity-val').textContent = Math.round(this.penOpacity * 100) + '%';
    document.getElementById('pp-pressure').checked = this.penPressure;
    document.getElementById('pp-smoothing').checked = this.penSmoothing;
    document.getElementById('pp-eraser-radius').value = this.eraserRadius;
    document.getElementById('pp-eraser-val').textContent = this.eraserRadius + 'px';
    document.querySelectorAll('.pp-mode').forEach(b => b.classList.toggle('active', b.dataset.mode === this.penMode));
    document.querySelectorAll('.pp-swatch').forEach(s => s.classList.toggle('active', s.style.background === this.penColor || this.rgbMatch(s.style.background, this.penColor)));
    this.updateWidthDot();
    panel.classList.add('show');
  },

  hidePenPanel() {
    document.getElementById('pen-panel').classList.remove('show');
  },

  setPenColor(c) {
    this.penColor = c;
    document.querySelectorAll('.pp-swatch').forEach(s => s.classList.toggle('active', this.rgbMatch(s.style.background, c)));
    const custom = document.querySelector('.pp-custom-color');
    if (custom) custom.value = c;
  },

  setPenWidth(w) {
    this.penWidth = w;
    document.getElementById('pp-width-val').textContent = w + 'px';
    this.updateWidthDot();
  },

  setPenOpacity(o) {
    this.penOpacity = Math.max(0.05, Math.min(1, o));
    document.getElementById('pp-opacity').value = Math.round(this.penOpacity * 100);
    document.getElementById('pp-opacity-val').textContent = Math.round(this.penOpacity * 100) + '%';
  },

  setPenMode(mode) {
    this.penMode = mode;
    document.querySelectorAll('.pp-mode').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
    // Apply mode presets
    const presets = { pen: { w: 3, o: 1 }, marker: { w: 8, o: 0.7 }, highlighter: { w: 20, o: 0.3 } };
    const p = presets[mode];
    this.setPenWidth(p.w);
    this.setPenOpacity(p.o);
    document.getElementById('pp-width').value = p.w;
    document.getElementById('pp-opacity').value = Math.round(p.o * 100);
    this.toast(`Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`);
  },

  togglePressure() {
    this.penPressure = !this.penPressure;
    document.getElementById('pp-pressure').checked = this.penPressure;
    this.toast(`Pressure: ${this.penPressure ? 'On' : 'Off'}`);
  },

  toggleSmoothing() {
    this.penSmoothing = !this.penSmoothing;
    document.getElementById('pp-smoothing').checked = this.penSmoothing;
    this.toast(`Smoothing: ${this.penSmoothing ? 'On' : 'Off'}`);
  },

  setEraserRadius(r) {
    this.eraserRadius = r;
    document.getElementById('pp-eraser-val').textContent = r + 'px';
  },

  updateWidthDot() {
    const dot = document.getElementById('pp-width-dot');
    if (dot) {
      const sz = Math.max(4, this.penWidth * 1.5);
      dot.style.width = sz + 'px';
      dot.style.height = sz + 'px';
      dot.style.background = this.penColor;
      dot.style.opacity = this.penOpacity;
    }
  },

  rgbMatch(rgb, hex) {
    // Compare browser-computed rgb() string with hex color
    if (!rgb || !hex) return false;
    const tmp = document.createElement('div');
    tmp.style.color = hex;
    document.body.appendChild(tmp);
    const computed = getComputedStyle(tmp).color;
    document.body.removeChild(tmp);
    return rgb === computed;
  },

  // ─── Shape options panel ──────────────────────────────
  buildShapePanel() {
    const fillGrid = document.getElementById('sp-fill-grid');
    const strokeGrid = document.getElementById('sp-stroke-grid');
    // Fill swatches
    SHAPE_FILLS.forEach(c => {
      const sw = document.createElement('div');
      sw.className = 'pp-swatch';
      sw.style.background = c === 'transparent' ? 'linear-gradient(45deg,#ccc 25%,transparent 25%,transparent 75%,#ccc 75%),linear-gradient(45deg,#ccc 25%,transparent 25%,transparent 75%,#ccc 75%)' : c;
      if (c === 'transparent') { sw.style.backgroundSize = '8px 8px'; sw.style.backgroundPosition = '0 0,4px 4px'; }
      sw.dataset.color = c;
      sw.onclick = () => this.setShapeFill(c);
      fillGrid.appendChild(sw);
    });
    // Custom fill picker
    const customFill = document.createElement('input');
    customFill.type = 'color';
    customFill.className = 'pp-custom-color';
    customFill.value = '#292524';
    customFill.title = 'Custom fill';
    customFill.oninput = () => this.setShapeFill(customFill.value);
    fillGrid.appendChild(customFill);
    // Stroke swatches
    STROKE_COLORS.forEach(c => {
      const sw = document.createElement('div');
      sw.className = 'pp-swatch';
      sw.style.background = c;
      sw.dataset.color = c;
      sw.onclick = () => this.setShapeStroke(c);
      strokeGrid.appendChild(sw);
    });
    // Custom stroke picker
    const customStroke = document.createElement('input');
    customStroke.type = 'color';
    customStroke.className = 'pp-custom-color';
    customStroke.value = '#f59e0b';
    customStroke.title = 'Custom stroke';
    customStroke.oninput = () => this.setShapeStroke(customStroke.value);
    strokeGrid.appendChild(customStroke);
  },

  showShapePanel() {
    const panel = document.getElementById('shape-panel');
    // Sync controls
    document.getElementById('sp-stroke-width').value = this.shapeStrokeWidth;
    document.getElementById('sp-stroke-width-val').textContent = this.shapeStrokeWidth + 'px';
    // Highlight active swatches
    const currentFill = this.shapeFill || this._themeBg2();
    const currentStroke = this.shapeStroke || this._themeAccent();
    document.querySelectorAll('#sp-fill-grid .pp-swatch').forEach(s => s.classList.toggle('active', s.dataset.color === currentFill || this.rgbMatch(s.style.background, currentFill)));
    document.querySelectorAll('#sp-stroke-grid .pp-swatch').forEach(s => s.classList.toggle('active', s.dataset.color === currentStroke || this.rgbMatch(s.style.background, currentStroke)));
    document.querySelectorAll('#sp-dash-options .pp-dash-btn').forEach(b => b.classList.toggle('active', b.dataset.dash === this.shapeStrokeDash));
    panel.classList.add('show');
  },

  hideShapePanel() {
    document.getElementById('shape-panel').classList.remove('show');
  },

  setShapeFill(c) {
    this.shapeFill = c;
    document.querySelectorAll('#sp-fill-grid .pp-swatch').forEach(s => s.classList.toggle('active', s.dataset.color === c || this.rgbMatch(s.style.background, c)));
    const custom = document.querySelector('#sp-fill-grid .pp-custom-color');
    if (custom && c.startsWith('#')) custom.value = c;
  },

  setShapeStroke(c) {
    this.shapeStroke = c;
    document.querySelectorAll('#sp-stroke-grid .pp-swatch').forEach(s => s.classList.toggle('active', s.dataset.color === c || this.rgbMatch(s.style.background, c)));
    const custom = document.querySelector('#sp-stroke-grid .pp-custom-color');
    if (custom && c.startsWith('#')) custom.value = c;
  },

  setShapeStrokeWidth(w) {
    this.shapeStrokeWidth = w;
    document.getElementById('sp-stroke-width-val').textContent = w + 'px';
  },

  setShapeStrokeDash(d) {
    this.shapeStrokeDash = d;
    document.querySelectorAll('#sp-dash-options .pp-dash-btn').forEach(b => b.classList.toggle('active', b.dataset.dash === d));
  },

  toggleSidebar() {
    this.sidebarExpanded = !this.sidebarExpanded;
    document.getElementById('sidebar').classList.toggle('expanded', this.sidebarExpanded);
  },

  // ─── Canvas coordinate transforms ───────────────────────
  screenToCanvas(sx, sy) {
    const r = document.getElementById('svg-canvas').getBoundingClientRect();
    return {
      x: (sx - r.left) / this.viewport.zoom + this.viewport.x,
      y: (sy - r.top) / this.viewport.zoom + this.viewport.y,
    };
  },

  canvasToScreen(cx, cy) {
    const r = document.getElementById('svg-canvas').getBoundingClientRect();
    return {
      x: (cx - this.viewport.x) * this.viewport.zoom + r.left,
      y: (cy - this.viewport.y) * this.viewport.zoom + r.top,
    };
  },

  snapVal(v) { return this.snapToGrid ? Math.round(v / this.gridSize) * this.gridSize : v; },

  updateViewBox() {
    const svg = document.getElementById('svg-canvas');
    const r = svg.getBoundingClientRect();
    const w = r.width / this.viewport.zoom;
    const h = r.height / this.viewport.zoom;
    svg.setAttribute('viewBox', `${this.viewport.x} ${this.viewport.y} ${w} ${h}`);
    document.getElementById('zoom-display').textContent = Math.round(this.viewport.zoom * 100) + '%';
    this.updateMinimap();

    // Update grid pattern scale
    const pat = document.getElementById('grid-dots');
    const gs = this.gridSize;
    pat.setAttribute('width', gs);
    pat.setAttribute('height', gs);
    pat.querySelector('circle').setAttribute('cx', gs/2);
    pat.querySelector('circle').setAttribute('cy', gs/2);
  },

  // ─── Zoom / Pan ──────────────────────────────────────────
  zoomIn() { this.zoomTo(this.viewport.zoom * 1.2); },
  zoomOut() { this.zoomTo(this.viewport.zoom / 1.2); },

  zoomTo(z, cx, cy) {
    const svg = document.getElementById('svg-canvas');
    const r = svg.getBoundingClientRect();
    if (cx === undefined) { cx = r.left + r.width / 2; cy = r.top + r.height / 2; }
    const oldZ = this.viewport.zoom;
    const newZ = clamp(z, 0.1, 10);
    const p = this.screenToCanvas(cx, cy);
    this.viewport.zoom = newZ;
    this.viewport.x = p.x - (cx - r.left) / newZ;
    this.viewport.y = p.y - (cy - r.top) / newZ;
    this.updateViewBox();
  },

  fitToScreen() {
    if (this.elements.length === 0) {
      this.viewport = { x: -500, y: -300, zoom: 1 };
      this.updateViewBox();
      return;
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    this.elements.forEach(el => {
      const b = this.getElementBounds(el);
      minX = Math.min(minX, b.x);
      minY = Math.min(minY, b.y);
      maxX = Math.max(maxX, b.x + b.w);
      maxY = Math.max(maxY, b.y + b.h);
    });
    const svg = document.getElementById('svg-canvas').getBoundingClientRect();
    const pad = 60;
    const w = maxX - minX + pad * 2;
    const h = maxY - minY + pad * 2;
    const z = Math.min(svg.width / w, svg.height / h, 3);
    this.viewport.zoom = z;
    this.viewport.x = minX - pad - (svg.width / z - w) / 2;
    this.viewport.y = minY - pad - (svg.height / z - h) / 2;
    this.updateViewBox();
  },

  // ─── Events ──────────────────────────────────────────────
  bindEvents() {
    const svg = document.getElementById('svg-canvas');
    const drawCanvas = document.getElementById('draw-canvas');

    // Pointer events on SVG (shapes, selection, pan)
    svg.addEventListener('pointerdown', (e) => this.onPointerDown(e));
    svg.addEventListener('pointermove', (e) => this.onPointerMove(e));
    svg.addEventListener('pointerup', (e) => this.onPointerUp(e));
    svg.addEventListener('pointercancel', (e) => this.onPointerUp(e));

    // Pointer events on draw canvas (freehand)
    drawCanvas.addEventListener('pointerdown', (e) => this.onDrawDown(e));
    drawCanvas.addEventListener('pointermove', (e) => this.onDrawMove(e));
    drawCanvas.addEventListener('pointerup', (e) => this.onDrawUp(e));
    drawCanvas.addEventListener('pointercancel', (e) => this.onDrawUp(e));

    // Scroll for zoom
    document.getElementById('canvas-wrap').addEventListener('wheel', (e) => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.92 : 1.08;
      this.zoomTo(this.viewport.zoom * factor, e.clientX, e.clientY);
    }, { passive: false });

    // Keyboard
    window.addEventListener('keydown', (e) => this.onKeyDown(e));

    // Resize
    window.addEventListener('resize', () => this.resizeCanvas());

    // Context menu
    svg.addEventListener('contextmenu', (e) => { e.preventDefault(); this.showContextMenu(e); });
    document.addEventListener('click', () => this.hideContextMenu());

    // Double click to edit
    svg.addEventListener('dblclick', (e) => this.onDblClick(e));

    // Drag & drop symbols from symbol panel onto canvas
    svg.addEventListener('dragover', (e) => e.preventDefault());
    svg.addEventListener('drop', (e) => {
      e.preventDefault();
      try {
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        if (data.type === 'symbol') {
          const rect = svg.getBoundingClientRect();
          const mx = (e.clientX - rect.left) / this.zoom - this.viewport.x;
          const my = (e.clientY - rect.top) / this.zoom - this.viewport.y;
          const symbols = this.SYMBOLS[data.cat];
          if (symbols && symbols[data.idx]) {
            const s = symbols[data.idx];
            this.pushUndo();
            const el = this.createElement('engineering-block', mx - 60, my - 40, 120, 80);
            el.text = s.name;
            el.symbolPath = s.path;
            el.symbolExtra = s.extra || '';
            el.symbolLabel = s.label || '';
            el.symbolCircle = s.circle || false;
            el.symbolFill = s.fillColor || '';
            el.symbolDash = s.dasharray || '';
            el.opacity = 1;
            el.iconScale = 1;
            this.elements.push(el);
            this.selection = [el.id];
            this.render();
            this.saveData();
            this.toast(`Placed: ${s.name}`);
          }
        }
      } catch(err) {}
    });

    // Touch gestures (2-finger zoom handled by pointer events)
    // Prevent default touch actions on canvas
    svg.style.touchAction = 'none';
    drawCanvas.style.touchAction = 'none';
  },

  resizeCanvas() {
    const wrap = document.getElementById('canvas-wrap');
    const dc = document.getElementById('draw-canvas');
    dc.width = wrap.clientWidth * (window.devicePixelRatio || 1);
    dc.height = wrap.clientHeight * (window.devicePixelRatio || 1);
    dc.style.width = wrap.clientWidth + 'px';
    dc.style.height = wrap.clientHeight + 'px';
    const ctx = dc.getContext('2d');
    ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
    this.updateViewBox();
    this.renderFreehandStrokes();
  },

  // ─── Pointer handling (SVG canvas) ───────────────────────
  _pointers: new Map(),

  onPointerDown(e) {
    this._pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // Finger on tablet = always pan
    if (e.pointerType === 'touch') {
      if (this._pointers.size === 1) {
        this._panStart = { x: e.clientX, y: e.clientY, vx: this.viewport.x, vy: this.viewport.y };
      }
      return;
    }

    const p = this.screenToCanvas(e.clientX, e.clientY);

    if (this.tool === 'pan') {
      this._panStart = { x: e.clientX, y: e.clientY, vx: this.viewport.x, vy: this.viewport.y };
      document.getElementById('canvas-wrap').style.cursor = 'grabbing';
      return;
    }

    if (this.tool === 'select') {
      const hit = this.hitTest(p.x, p.y);
      if (hit) {
        // Check if clicking a resize handle
        const handle = this.hitResizeHandle(p.x, p.y, hit);
        if (handle) {
          this.resizing = { el: hit, handle, startX: p.x, startY: p.y, orig: { x: hit.x, y: hit.y, width: hit.width || 0, height: hit.height || 0 } };
          return;
        }
        if (!e.shiftKey && !this.selection.includes(hit.id)) {
          this.selection = [hit.id];
        } else if (e.shiftKey) {
          if (this.selection.includes(hit.id)) {
            this.selection = this.selection.filter(id => id !== hit.id);
          } else {
            this.selection.push(hit.id);
          }
        }
        this.dragging = { startX: p.x, startY: p.y, origPositions: this.getSelectedElements().map(el => ({ id: el.id, x: el.x, y: el.y })) };
        this.render();
        this.showPropsBar();
      } else {
        this.selection = [];
        this.rubberBand = { startX: p.x, startY: p.y, x: p.x, y: p.y, w: 0, h: 0 };
        this.render();
        this.hidePropsBar();
      }
      return;
    }

    if (this.tool === 'eraser') {
      const r = this.eraserRadius / this.viewport.zoom;
      const hit = this.hitTestRadius(p.x, p.y, r);
      if (hit) {
        this.pushUndo();
        this.elements = this.elements.filter(el => el.id !== hit.id);
        this.selection = [];
        this.render();
        this.saveData();
      }
      return;
    }

    // Lasso tool
    if (this.tool === 'lasso') {
      this.startLasso(p.x, p.y);
      return;
    }

    // Shape creation tools
    if (['rectangle', 'ellipse', 'diamond', 'text', 'sticky'].includes(this.tool)) {
      const sx = this.snapVal(p.x);
      const sy = this.snapVal(p.y);
      this.drawing = {
        type: this.tool,
        startX: sx, startY: sy,
        x: sx, y: sy, width: 0, height: 0
      };
      return;
    }

    // Line / Arrow / Connector
    if (['line', 'arrow', 'connector'].includes(this.tool)) {
      this.drawing = {
        type: this.tool,
        startX: p.x, startY: p.y,
        endX: p.x, endY: p.y
      };
      return;
    }
  },

  onPointerMove(e) {
    this._pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    // Eraser cursor
    const ec = document.getElementById('eraser-cursor');
    if (this.tool === 'eraser') {
      const sz = this.eraserRadius * 2 * this.viewport.zoom;
      ec.style.display = 'block';
      ec.style.width = sz + 'px';
      ec.style.height = sz + 'px';
      ec.style.left = e.clientX + 'px';
      ec.style.top = e.clientY + 'px';
    } else {
      ec.style.display = 'none';
    }

    // Touch pinch zoom
    if (e.pointerType === 'touch' && this._pointers.size === 2) {
      const pts = [...this._pointers.values()];
      const newDist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
      const cx = (pts[0].x + pts[1].x) / 2;
      const cy = (pts[0].y + pts[1].y) / 2;
      if (this._lastPinchDist) {
        const scale = newDist / this._lastPinchDist;
        this.zoomTo(this.viewport.zoom * scale, cx, cy);
      }
      this._lastPinchDist = newDist;
      return;
    }

    // Touch pan (single finger)
    if (e.pointerType === 'touch' && this._panStart) {
      const dx = (e.clientX - this._panStart.x) / this.viewport.zoom;
      const dy = (e.clientY - this._panStart.y) / this.viewport.zoom;
      this.viewport.x = this._panStart.vx - dx;
      this.viewport.y = this._panStart.vy - dy;
      this.updateViewBox();
      return;
    }

    const p = this.screenToCanvas(e.clientX, e.clientY);

    // Pan
    if (this._panStart && this.tool === 'pan') {
      const dx = (e.clientX - this._panStart.x) / this.viewport.zoom;
      const dy = (e.clientY - this._panStart.y) / this.viewport.zoom;
      this.viewport.x = this._panStart.vx - dx;
      this.viewport.y = this._panStart.vy - dy;
      this.updateViewBox();
      return;
    }

    // Space+drag pan
    if (this._panStart && this._spaceDown) {
      const dx = (e.clientX - this._panStart.x) / this.viewport.zoom;
      const dy = (e.clientY - this._panStart.y) / this.viewport.zoom;
      this.viewport.x = this._panStart.vx - dx;
      this.viewport.y = this._panStart.vy - dy;
      this.updateViewBox();
      return;
    }

    // Lasso
    if (this.lassoActive) {
      this.updateLasso(p.x, p.y);
      return;
    }

    // Dragging selection
    if (this.dragging) {
      const dx = p.x - this.dragging.startX;
      const dy = p.y - this.dragging.startY;
      this.dragging.origPositions.forEach(op => {
        const el = this.elements.find(e => e.id === op.id);
        if (el) {
          el.x = this.snapVal(op.x + dx);
          el.y = this.snapVal(op.y + dy);
        }
      });
      this.render();
      return;
    }

    // Resizing
    if (this.resizing) {
      const { el, handle, startX, startY, orig } = this.resizing;
      const dx = p.x - startX;
      const dy = p.y - startY;
      if (handle.includes('r')) { el.width = Math.max(20, this.snapVal(orig.width + dx)); }
      if (handle.includes('b')) { el.height = Math.max(20, this.snapVal(orig.height + dy)); }
      if (handle.includes('l')) { el.x = this.snapVal(orig.x + dx); el.width = Math.max(20, this.snapVal(orig.width - dx)); }
      if (handle.includes('t')) { el.y = this.snapVal(orig.y + dy); el.height = Math.max(20, this.snapVal(orig.height - dy)); }
      this.render();
      return;
    }

    // Rubber band selection
    if (this.rubberBand) {
      this.rubberBand.x = Math.min(this.rubberBand.startX, p.x);
      this.rubberBand.y = Math.min(this.rubberBand.startY, p.y);
      this.rubberBand.w = Math.abs(p.x - this.rubberBand.startX);
      this.rubberBand.h = Math.abs(p.y - this.rubberBand.startY);
      this.renderRubberBand();
      return;
    }

    // Drawing shapes
    if (this.drawing && ['rectangle', 'ellipse', 'diamond', 'text', 'sticky'].includes(this.drawing.type)) {
      const sx = this.snapVal(p.x);
      const sy = this.snapVal(p.y);
      this.drawing.x = Math.min(this.drawing.startX, sx);
      this.drawing.y = Math.min(this.drawing.startY, sy);
      this.drawing.width = Math.abs(sx - this.drawing.startX);
      this.drawing.height = Math.abs(sy - this.drawing.startY);
      this.renderDrawingPreview();
      return;
    }

    // Drawing lines
    if (this.drawing && ['line', 'arrow', 'connector'].includes(this.drawing.type)) {
      this.drawing.endX = p.x;
      this.drawing.endY = p.y;
      this.renderDrawingPreview();
      return;
    }
  },

  onPointerUp(e) {
    this._pointers.delete(e.pointerId);
    this._lastPinchDist = null;

    if (e.pointerType === 'touch') {
      this._panStart = null;
      return;
    }

    if (this._panStart) {
      this._panStart = null;
      document.getElementById('canvas-wrap').style.cursor = this.tool === 'pan' ? 'grab' : 'default';
    }

    // Finish lasso
    if (this.lassoActive) {
      this.endLasso();
      return;
    }

    // Finish drag
    if (this.dragging) {
      this.pushUndo();
      this.dragging = null;
      this.saveData();
    }

    // Finish resize
    if (this.resizing) {
      this.pushUndo();
      this.resizing = null;
      this.saveData();
    }

    // Finish rubber band
    if (this.rubberBand) {
      if (this.rubberBand.w > 5 || this.rubberBand.h > 5) {
        this.selection = this.elements.filter(el => {
          const b = this.getElementBounds(el);
          return b.x >= this.rubberBand.x && b.y >= this.rubberBand.y &&
                 b.x + b.w <= this.rubberBand.x + this.rubberBand.w &&
                 b.y + b.h <= this.rubberBand.y + this.rubberBand.h;
        }).map(el => el.id);
      }
      this.rubberBand = null;
      this.render();
    }

    // Finish drawing shape
    if (this.drawing) {
      const d = this.drawing;
      this.drawing = null;
      this.clearOverlay();

      if (['rectangle', 'ellipse', 'diamond'].includes(d.type) && d.width > 5 && d.height > 5) {
        this.pushUndo();
        const el = this.createElement(d.type, d.x, d.y, d.width, d.height);
        this.elements.push(el);
        this.selection = [el.id];
        this.render();
        this.saveData();
      } else if (d.type === 'text') {
        this.pushUndo();
        const el = this.createElement('text', d.startX, d.startY, Math.max(d.width, 120), Math.max(d.height, 32));
        el.text = 'Text';
        this.elements.push(el);
        this.selection = [el.id];
        this.render();
        this.saveData();
        setTimeout(() => this.editElement(el.id), 50);
      } else if (d.type === 'sticky') {
        this.pushUndo();
        const w = Math.max(d.width, 160);
        const h = Math.max(d.height, 120);
        const el = this.createElement('sticky', d.x, d.y, w, h);
        el.fill = STICKY_COLORS[Math.floor(Math.random() * STICKY_COLORS.length)];
        el.stroke = 'transparent';
        el.text = 'Note';
        el.fontSize = 14;
        this.elements.push(el);
        this.selection = [el.id];
        this.render();
        this.saveData();
      } else if (['line', 'arrow', 'connector'].includes(d.type)) {
        const len = Math.hypot(d.endX - d.startX, d.endY - d.startY);
        if (len > 10) {
          this.pushUndo();
          const el = {
            id: uid(),
            type: d.type,
            x: d.startX, y: d.startY,
            x2: d.endX, y2: d.endY,
            stroke: d.type === 'connector' ? '#71717a' : '#f59e0b',
            strokeWidth: 2,
            opacity: 1,
            locked: false,
            text: '',
          };
          this.elements.push(el);
          this.selection = [el.id];
          this.render();
          this.saveData();
        }
      }
    }
  },

  // ─── Freehand drawing (Canvas overlay) ───────────────────
  _currentStroke: null,

  onDrawDown(e) {
    // Only draw with pen/stylus or mouse; finger = pan
    if (e.pointerType === 'touch') {
      this._panStart = { x: e.clientX, y: e.clientY, vx: this.viewport.x, vy: this.viewport.y };
      return;
    }
    // Eraser: delegate to SVG hit-test erase logic
    if (this.tool === 'eraser') {
      const p = this.screenToCanvas(e.clientX, e.clientY);
      const r = this.eraserRadius / this.viewport.zoom;
      const hit = this.hitTestRadius(p.x, p.y, r);
      if (hit) {
        this.pushUndo();
        this.elements = this.elements.filter(el => el.id !== hit.id);
        this.selection = [];
        this.render();
        this.saveData();
      }
      return;
    }
    e.target.setPointerCapture(e.pointerId);
    const p = this.screenToCanvas(e.clientX, e.clientY);
    this._currentStroke = {
      points: [{ x: p.x, y: p.y, pressure: e.pressure || 0.5 }],
      color: this.penColor,
      baseWidth: this.penWidth,
      opacity: this.penOpacity,
      mode: this.penMode,
    };
  },

  onDrawMove(e) {
    // Update eraser cursor on draw canvas
    if (this.tool === 'eraser') {
      const ec = document.getElementById('eraser-cursor');
      const sz = this.eraserRadius * 2 * this.viewport.zoom;
      ec.style.display = 'block';
      ec.style.width = sz + 'px';
      ec.style.height = sz + 'px';
      ec.style.left = e.clientX + 'px';
      ec.style.top = e.clientY + 'px';
    }
    if (e.pointerType === 'touch' && this._panStart) {
      const dx = (e.clientX - this._panStart.x) / this.viewport.zoom;
      const dy = (e.clientY - this._panStart.y) / this.viewport.zoom;
      this.viewport.x = this._panStart.vx - dx;
      this.viewport.y = this._panStart.vy - dy;
      this.updateViewBox();
      this.renderFreehandStrokes();
      return;
    }
    if (!this._currentStroke) return;
    const p = this.screenToCanvas(e.clientX, e.clientY);
    this._currentStroke.points.push({ x: p.x, y: p.y, pressure: e.pressure || 0.5 });
    this.renderCurrentStroke();
  },

  onDrawUp(e) {
    if (e.pointerType === 'touch') { this._panStart = null; return; }
    if (!this._currentStroke) return;
    if (this._currentStroke.points.length > 1) {
      this.pushUndo();
      let pts = this._currentStroke.points;
      if (this.penSmoothing && pts.length > 4) pts = smoothPoints(pts);
      const el = {
        id: uid(),
        type: 'freehand',
        points: pts,
        stroke: this._currentStroke.color,
        strokeWidth: this._currentStroke.baseWidth,
        opacity: this._currentStroke.opacity,
        mode: this._currentStroke.mode || 'pen',
        locked: false,
      };
      // Compute bounding box
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      el.points.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
      el.x = minX; el.y = minY; el.width = maxX - minX; el.height = maxY - minY;
      this.elements.push(el);
      this.saveData();
    }
    this._currentStroke = null;
    this.renderFreehandStrokes();
  },

  renderCurrentStroke() {
    const dc = document.getElementById('draw-canvas');
    const ctx = dc.getContext('2d');
    const wrap = document.getElementById('canvas-wrap');
    // Clear and redraw all freehand + current stroke
    ctx.clearRect(0, 0, wrap.clientWidth, wrap.clientHeight);
    this.drawFreehandElements(ctx);
    // Draw current stroke
    const pts = this._currentStroke.points;
    if (pts.length < 2) return;
    const mode = this._currentStroke.mode || 'pen';
    const isHL = mode === 'highlighter';
    ctx.strokeStyle = this._currentStroke.color;
    ctx.lineCap = (mode === 'pen') ? 'round' : 'square';
    ctx.lineJoin = 'round';
    ctx.globalAlpha = this._currentStroke.opacity;
    ctx.globalCompositeOperation = isHL ? 'destination-over' : 'source-over';
    for (let i = 1; i < pts.length; i++) {
      const p0 = pts[i-1], p1 = pts[i];
      const s0 = this.canvasToScreenLocal(p0.x, p0.y);
      const s1 = this.canvasToScreenLocal(p1.x, p1.y);
      const usePressure = this.penPressure && !isHL;
      const w = usePressure ? this._currentStroke.baseWidth * (p1.pressure * 1.5 + 0.3) : this._currentStroke.baseWidth;
      ctx.lineWidth = w * this.viewport.zoom;
      ctx.beginPath();
      ctx.moveTo(s0.x, s0.y);
      ctx.lineTo(s1.x, s1.y);
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
  },

  renderFreehandStrokes() {
    const dc = document.getElementById('draw-canvas');
    const ctx = dc.getContext('2d');
    const wrap = document.getElementById('canvas-wrap');
    ctx.clearRect(0, 0, wrap.clientWidth, wrap.clientHeight);
    this.drawFreehandElements(ctx);
  },

  drawFreehandElements(ctx) {
    // Draw highlighter strokes first (behind everything)
    const freehand = this.elements.filter(el => el.type === 'freehand');
    const highlighters = freehand.filter(el => el.mode === 'highlighter');
    const others = freehand.filter(el => el.mode !== 'highlighter');
    [...highlighters, ...others].forEach(el => {
      const pts = el.points;
      if (!pts || pts.length < 2) return;
      const mode = el.mode || 'pen';
      const isHL = mode === 'highlighter';
      ctx.strokeStyle = el.stroke;
      ctx.lineCap = (mode === 'pen') ? 'round' : 'square';
      ctx.lineJoin = 'round';
      ctx.globalAlpha = el.opacity || 1;
      const usePressure = this.penPressure && !isHL;
      for (let i = 1; i < pts.length; i++) {
        const p0 = pts[i-1], p1 = pts[i];
        const s0 = this.canvasToScreenLocal(p0.x, p0.y);
        const s1 = this.canvasToScreenLocal(p1.x, p1.y);
        const pressure = p1.pressure || 0.5;
        const w = usePressure ? el.strokeWidth * (pressure * 1.5 + 0.3) : el.strokeWidth;
        ctx.lineWidth = w * this.viewport.zoom;
        ctx.beginPath();
        ctx.moveTo(s0.x, s0.y);
        ctx.lineTo(s1.x, s1.y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    });
  },

  canvasToScreenLocal(cx, cy) {
    return {
      x: (cx - this.viewport.x) * this.viewport.zoom,
      y: (cy - this.viewport.y) * this.viewport.zoom,
    };
  },

  // ─── Element creation ────────────────────────────────────
  _themeAccent() {
    return getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#f59e0b';
  },
  _themeBg2() {
    return getComputedStyle(document.documentElement).getPropertyValue('--bg2').trim() || '#292524';
  },

  createElement(type, x, y, w, h) {
    const accentColor = this._themeAccent();
    const bgColor = this._themeBg2();
    const isShape = ['rectangle','ellipse','diamond','line','arrow','connector'].includes(type);
    return {
      id: uid(),
      type,
      x, y,
      width: w,
      height: h,
      rotation: 0,
      fill: type === 'text' ? 'transparent' : (isShape && this.shapeFill != null ? this.shapeFill : bgColor),
      stroke: isShape && this.shapeStroke != null ? this.shapeStroke : accentColor,
      strokeWidth: isShape ? this.shapeStrokeWidth : 2,
      strokeDasharray: isShape ? this.shapeStrokeDash : '',
      text: '',
      fontSize: 14,
      textAlign: 'center',
      opacity: 1,
      locked: false,
      ports: [],
      metadata: {},
    };
  },

  // ─── Hit testing ─────────────────────────────────────────
  hitTest(x, y) {
    // Reverse order (top element first)
    for (let i = this.elements.length - 1; i >= 0; i--) {
      const el = this.elements[i];
      if (el.type === 'freehand') {
        // Check bounding box
        if (x >= el.x - 10 && x <= el.x + el.width + 10 && y >= el.y - 10 && y <= el.y + el.height + 10) return el;
        continue;
      }
      if (['line', 'arrow', 'connector'].includes(el.type)) {
        const d = this.distToLine(x, y, el.x, el.y, el.x2, el.y2);
        if (d < 8) return el;
        continue;
      }
      const b = this.getElementBounds(el);
      if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) return el;
    }
    return null;
  },

  hitTestRadius(x, y, radius) {
    for (let i = this.elements.length - 1; i >= 0; i--) {
      const el = this.elements[i];
      if (el.type === 'freehand') {
        // Check if any point is within radius
        if (el.points && el.points.some(pt => Math.hypot(pt.x - x, pt.y - y) < radius)) return el;
        continue;
      }
      if (['line', 'arrow', 'connector'].includes(el.type)) {
        if (this.distToLine(x, y, el.x, el.y, el.x2, el.y2) < radius) return el;
        continue;
      }
      const b = this.getElementBounds(el);
      if (x >= b.x - radius && x <= b.x + b.w + radius && y >= b.y - radius && y <= b.y + b.h + radius) return el;
    }
    return null;
  },

  distToLine(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const len2 = dx * dx + dy * dy;
    if (len2 === 0) return Math.hypot(px - x1, py - y1);
    let t = ((px - x1) * dx + (py - y1) * dy) / len2;
    t = clamp(t, 0, 1);
    return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
  },

  hitResizeHandle(x, y, el) {
    if (['line', 'arrow', 'connector', 'freehand'].includes(el.type)) return null;
    const b = this.getElementBounds(el);
    const hs = 6 / this.viewport.zoom;
    const handles = [
      { name: 'tl', x: b.x, y: b.y },
      { name: 'tr', x: b.x + b.w, y: b.y },
      { name: 'bl', x: b.x, y: b.y + b.h },
      { name: 'br', x: b.x + b.w, y: b.y + b.h },
      { name: 'r', x: b.x + b.w, y: b.y + b.h / 2 },
      { name: 'b', x: b.x + b.w / 2, y: b.y + b.h },
      { name: 'l', x: b.x, y: b.y + b.h / 2 },
      { name: 't', x: b.x + b.w / 2, y: b.y },
    ];
    for (const h of handles) {
      if (Math.abs(x - h.x) < hs && Math.abs(y - h.y) < hs) return h.name;
    }
    return null;
  },

  getElementBounds(el) {
    if (['line', 'arrow', 'connector'].includes(el.type)) {
      return {
        x: Math.min(el.x, el.x2),
        y: Math.min(el.y, el.y2),
        w: Math.abs(el.x2 - el.x),
        h: Math.abs(el.y2 - el.y),
      };
    }
    return { x: el.x, y: el.y, w: el.width || 0, h: el.height || 0 };
  },

  getSelectedElements() {
    return this.elements.filter(el => this.selection.includes(el.id));
  },

  // ─── Undo / Redo ─────────────────────────────────────────
  pushUndo() {
    this.undoStack.push(JSON.stringify(this.elements));
    if (this.undoStack.length > 50) this.undoStack.shift();
    this.redoStack = [];
  },

  undo() {
    if (this.undoStack.length === 0) return;
    this.redoStack.push(JSON.stringify(this.elements));
    this.elements = JSON.parse(this.undoStack.pop());
    this.selection = [];
    this.render();
    this.saveData();
  },

  redo() {
    if (this.redoStack.length === 0) return;
    this.undoStack.push(JSON.stringify(this.elements));
    this.elements = JSON.parse(this.redoStack.pop());
    this.selection = [];
    this.render();
    this.saveData();
  },

  // ─── Rendering ───────────────────────────────────────────
  render() {
    this.updateViewBox();
    this.renderElements();
    this.renderSelection();
    this.renderFreehandStrokes();
  },

  renderElements() {
    const g = document.getElementById('canvas-elements');
    const cg = document.getElementById('canvas-connectors');
    g.innerHTML = '';
    cg.innerHTML = '';

    this.elements.forEach(el => {
      if (el.type === 'freehand') return; // Rendered on canvas

      if (['line', 'arrow', 'connector'].includes(el.type)) {
        this.renderLine(cg, el);
        return;
      }

      const group = document.createElementNS(SVG_NS, 'g');
      group.setAttribute('data-id', el.id);
      group.style.opacity = el.opacity || 1;

      if (el.type === 'rectangle' || el.type === 'engineering-block') {
        const isSymbol = el.type === 'engineering-block';
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', el.x);
        rect.setAttribute('y', el.y);
        rect.setAttribute('width', el.width);
        rect.setAttribute('height', el.height);
        rect.setAttribute('rx', isSymbol ? 2 : 6);
        rect.setAttribute('fill', isSymbol ? 'var(--bg)' : (el.fill || this._themeBg2()));
        rect.setAttribute('stroke', isSymbol ? 'none' : (el.stroke || this._themeAccent()));
        rect.setAttribute('stroke-width', isSymbol ? 0 : (el.strokeWidth || 2));
        if (!isSymbol && el.strokeDasharray) rect.setAttribute('stroke-dasharray', el.strokeDasharray);
        group.appendChild(rect);

        // Render SVG symbol schematic inside engineering blocks
        if (el.type === 'engineering-block' && el.symbolPath) {
          const pad = 8;
          const labelH = el.text ? 20 : 0;
          const availW = el.width - pad * 2;
          const availH = el.height - pad * 2 - labelH;
          const baseScale = Math.min(availW / 24, availH / 24);
          const scale = baseScale * (el.iconScale || 1);
          const ox = el.x + (el.width - 24 * scale) / 2;
          const oy = el.y + pad + (availH - 24 * scale) / 2;
          const sg = document.createElementNS(SVG_NS, 'g');
          sg.setAttribute('transform', `translate(${ox},${oy}) scale(${scale})`);
          const sp = document.createElementNS(SVG_NS, 'path');
          sp.setAttribute('d', el.symbolPath);
          sp.setAttribute('fill', el.symbolFill || 'none');
          sp.setAttribute('stroke', el.stroke || this._themeAccent());
          sp.setAttribute('stroke-width', Math.max(1, 1.5 / scale));
          sp.setAttribute('stroke-linecap', 'round');
          sp.setAttribute('stroke-linejoin', 'round');
          if (el.symbolDash) sp.setAttribute('stroke-dasharray', el.symbolDash);
          sg.appendChild(sp);
          if (el.symbolCircle) {
            const circ = document.createElementNS(SVG_NS, 'circle');
            circ.setAttribute('cx', '12'); circ.setAttribute('cy', '12'); circ.setAttribute('r', '10');
            circ.setAttribute('fill', 'none');
            circ.setAttribute('stroke', el.stroke || this._themeAccent());
            circ.setAttribute('stroke-width', Math.max(1, 1.5 / scale));
            sg.appendChild(circ);
          }
          if (el.symbolExtra) {
            const ep = document.createElementNS(SVG_NS, 'path');
            ep.setAttribute('d', el.symbolExtra);
            ep.setAttribute('fill', 'none');
            ep.setAttribute('stroke', el.stroke || this._themeAccent());
            ep.setAttribute('stroke-width', Math.max(1, 1.5 / scale));
            ep.setAttribute('stroke-linecap', 'round');
            sg.appendChild(ep);
          }
          if (el.symbolLabel) {
            const lt = document.createElementNS(SVG_NS, 'text');
            lt.setAttribute('x', '12'); lt.setAttribute('y', '14');
            lt.setAttribute('text-anchor', 'middle');
            lt.setAttribute('font-size', '6');
            lt.setAttribute('fill', el.stroke || this._themeAccent());
            lt.setAttribute('stroke', 'none');
            lt.textContent = el.symbolLabel;
            sg.appendChild(lt);
          }
          group.appendChild(sg);
        }
      } else if (el.type === 'ellipse') {
        const ell = document.createElementNS(SVG_NS, 'ellipse');
        ell.setAttribute('cx', el.x + el.width / 2);
        ell.setAttribute('cy', el.y + el.height / 2);
        ell.setAttribute('rx', el.width / 2);
        ell.setAttribute('ry', el.height / 2);
        ell.setAttribute('fill', el.fill || this._themeBg2());
        ell.setAttribute('stroke', el.stroke || this._themeAccent());
        ell.setAttribute('stroke-width', el.strokeWidth || 2);
        if (el.strokeDasharray) ell.setAttribute('stroke-dasharray', el.strokeDasharray);
        group.appendChild(ell);
      } else if (el.type === 'diamond') {
        const cx = el.x + el.width / 2;
        const cy = el.y + el.height / 2;
        const poly = document.createElementNS(SVG_NS, 'polygon');
        poly.setAttribute('points', `${cx},${el.y} ${el.x + el.width},${cy} ${cx},${el.y + el.height} ${el.x},${cy}`);
        poly.setAttribute('fill', el.fill || this._themeBg2());
        poly.setAttribute('stroke', el.stroke || this._themeAccent());
        poly.setAttribute('stroke-width', el.strokeWidth || 2);
        if (el.strokeDasharray) poly.setAttribute('stroke-dasharray', el.strokeDasharray);
        group.appendChild(poly);
      } else if (el.type === 'sticky') {
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', el.x);
        rect.setAttribute('y', el.y);
        rect.setAttribute('width', el.width);
        rect.setAttribute('height', el.height);
        rect.setAttribute('rx', 4);
        rect.setAttribute('fill', el.fill || '#fbbf24');
        rect.setAttribute('stroke', 'none');
        // Subtle shadow
        rect.setAttribute('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,.2))');
        group.appendChild(rect);
        // Fold corner
        const fold = document.createElementNS(SVG_NS, 'path');
        const fx = el.x + el.width - 16;
        const fy = el.y;
        fold.setAttribute('d', `M${fx},${fy} L${el.x + el.width},${fy + 16} L${fx},${fy + 16} Z`);
        fold.setAttribute('fill', 'rgba(0,0,0,.1)');
        group.appendChild(fold);
      } else if (el.type === 'text') {
        // Just text, no background (or transparent bg)
        if (el.fill && el.fill !== 'transparent') {
          const rect = document.createElementNS(SVG_NS, 'rect');
          rect.setAttribute('x', el.x);
          rect.setAttribute('y', el.y);
          rect.setAttribute('width', el.width);
          rect.setAttribute('height', el.height);
          rect.setAttribute('rx', 4);
          rect.setAttribute('fill', el.fill);
          rect.setAttribute('stroke', el.stroke || 'none');
          rect.setAttribute('stroke-width', el.strokeWidth || 0);
          group.appendChild(rect);
        }
      }

      // Text label
      if (el.text && el.type !== 'freehand') {
        const isEngSym = el.type === 'engineering-block' && el.symbolPath;
        const fo = document.createElementNS(SVG_NS, 'foreignObject');
        fo.setAttribute('x', el.x + 4);
        fo.setAttribute('y', isEngSym ? el.y + el.height - 24 : el.y + 4);
        fo.setAttribute('width', el.width - 8);
        fo.setAttribute('height', isEngSym ? 20 : el.height - 8);
        const div = document.createElement('div');
        const engStyle = isEngSym ? `font-size:11px;color:var(--fg);opacity:0.7;` : '';
        div.style.cssText = isEngSym
          ? `width:100%;height:100%;display:flex;align-items:center;justify-content:center;${engStyle}overflow:hidden;word-break:break-word;line-height:1.1;white-space:nowrap;text-overflow:ellipsis;`
          : `width:100%;height:100%;display:flex;align-items:center;justify-content:${el.textAlign || 'center'};font-size:${el.fontSize || 14}px;color:${el.type === 'sticky' ? '#1a1a1a' : 'var(--fg)'};overflow:hidden;word-break:break-word;line-height:1.3;white-space:pre-wrap;padding:4px;`;
        div.textContent = el.text;
        fo.appendChild(div);
        group.appendChild(fo);
      }

      g.appendChild(group);
    });
  },

  renderLine(container, el) {
    const route = el.routeType || 'straight';
    if (route !== 'straight') {
      // Use path for elbow/curved connectors
      const path = document.createElementNS(SVG_NS, 'path');
      path.setAttribute('d', this.renderConnectorPath(el));
      path.setAttribute('stroke', el.stroke || this._themeAccent());
      path.setAttribute('stroke-width', el.strokeWidth || 2);
      path.setAttribute('fill', 'none');
      path.setAttribute('data-id', el.id);
      path.style.opacity = el.opacity || 1;
      if (el.type === 'arrow' || el.type === 'connector') path.setAttribute('marker-end', 'url(#arrow-end)');
      const pathDash = el.strokeDasharray || (el.type === 'connector' ? '6 3' : '');
      if (pathDash) path.setAttribute('stroke-dasharray', pathDash);
      container.appendChild(path);
    } else {
      const line = document.createElementNS(SVG_NS, 'line');
      line.setAttribute('x1', el.x);
      line.setAttribute('y1', el.y);
      line.setAttribute('x2', el.x2);
      line.setAttribute('y2', el.y2);
      line.setAttribute('stroke', el.stroke || this._themeAccent());
      line.setAttribute('stroke-width', el.strokeWidth || 2);
      line.setAttribute('data-id', el.id);
      line.style.opacity = el.opacity || 1;
      if (el.type === 'arrow' || el.type === 'connector') line.setAttribute('marker-end', 'url(#arrow-end)');
      const lineDash = el.strokeDasharray || (el.type === 'connector' ? '6 3' : '');
      if (lineDash) line.setAttribute('stroke-dasharray', lineDash);
      container.appendChild(line);
    }

    // Label at midpoint
    if (el.text) {
      const mx = (el.x + el.x2) / 2;
      const my = (el.y + el.y2) / 2;
      const txt = document.createElementNS(SVG_NS, 'text');
      txt.setAttribute('x', mx);
      txt.setAttribute('y', my - 6);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('fill', 'var(--fg2)');
      txt.setAttribute('font-size', '11');
      txt.setAttribute('font-family', 'var(--font)');
      txt.textContent = el.text;
      container.appendChild(txt);
    }
  },

  renderSelection() {
    const g = document.getElementById('canvas-selection');
    g.innerHTML = '';
    this.selection.forEach(id => {
      const el = this.elements.find(e => e.id === id);
      if (!el) return;
      const b = this.getElementBounds(el);
      const pad = 4;

      if (['line', 'arrow', 'connector'].includes(el.type)) {
        // Endpoint handles
        [{ x: el.x, y: el.y }, { x: el.x2, y: el.y2 }].forEach(pt => {
          const c = document.createElementNS(SVG_NS, 'circle');
          c.setAttribute('cx', pt.x);
          c.setAttribute('cy', pt.y);
          c.setAttribute('r', 4);
          c.setAttribute('class', 'element-handle');
          g.appendChild(c);
        });
        return;
      }

      // Selection rectangle
      const rect = document.createElementNS(SVG_NS, 'rect');
      rect.setAttribute('x', b.x - pad);
      rect.setAttribute('y', b.y - pad);
      rect.setAttribute('width', b.w + pad * 2);
      rect.setAttribute('height', b.h + pad * 2);
      rect.setAttribute('fill', 'none');
      rect.setAttribute('stroke', 'var(--accent)');
      rect.setAttribute('stroke-width', 1);
      rect.setAttribute('stroke-dasharray', '4 3');
      g.appendChild(rect);

      // Resize handles
      const hs = 5;
      const handles = [
        { x: b.x - pad, y: b.y - pad },
        { x: b.x + b.w + pad, y: b.y - pad },
        { x: b.x - pad, y: b.y + b.h + pad },
        { x: b.x + b.w + pad, y: b.y + b.h + pad },
      ];
      handles.forEach(h => {
        const r = document.createElementNS(SVG_NS, 'rect');
        r.setAttribute('x', h.x - hs);
        r.setAttribute('y', h.y - hs);
        r.setAttribute('width', hs * 2);
        r.setAttribute('height', hs * 2);
        r.setAttribute('rx', 2);
        r.setAttribute('class', 'element-handle');
        g.appendChild(r);
      });
    });
  },

  renderDrawingPreview() {
    const g = document.getElementById('canvas-overlay');
    g.innerHTML = '';
    if (!this.drawing) return;
    const d = this.drawing;

    if (['rectangle', 'ellipse', 'diamond', 'sticky'].includes(d.type)) {
      if (d.type === 'rectangle' || d.type === 'sticky') {
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', d.x);
        rect.setAttribute('y', d.y);
        rect.setAttribute('width', d.width);
        rect.setAttribute('height', d.height);
        rect.setAttribute('rx', d.type === 'sticky' ? 4 : 6);
        rect.setAttribute('fill', d.type === 'sticky' ? 'rgba(251,191,36,.3)' : 'rgba(41,37,36,.3)');
        rect.setAttribute('stroke', 'var(--accent)');
        rect.setAttribute('stroke-width', 2);
        rect.setAttribute('stroke-dasharray', '6 3');
        g.appendChild(rect);
      } else if (d.type === 'ellipse') {
        const ell = document.createElementNS(SVG_NS, 'ellipse');
        ell.setAttribute('cx', d.x + d.width / 2);
        ell.setAttribute('cy', d.y + d.height / 2);
        ell.setAttribute('rx', d.width / 2);
        ell.setAttribute('ry', d.height / 2);
        ell.setAttribute('fill', 'rgba(41,37,36,.3)');
        ell.setAttribute('stroke', 'var(--accent)');
        ell.setAttribute('stroke-width', 2);
        ell.setAttribute('stroke-dasharray', '6 3');
        g.appendChild(ell);
      } else if (d.type === 'diamond') {
        const cx = d.x + d.width / 2;
        const cy = d.y + d.height / 2;
        const poly = document.createElementNS(SVG_NS, 'polygon');
        poly.setAttribute('points', `${cx},${d.y} ${d.x + d.width},${cy} ${cx},${d.y + d.height} ${d.x},${cy}`);
        poly.setAttribute('fill', 'rgba(41,37,36,.3)');
        poly.setAttribute('stroke', 'var(--accent)');
        poly.setAttribute('stroke-width', 2);
        poly.setAttribute('stroke-dasharray', '6 3');
        g.appendChild(poly);
      }
    } else if (['line', 'arrow', 'connector'].includes(d.type)) {
      const line = document.createElementNS(SVG_NS, 'line');
      line.setAttribute('x1', d.startX);
      line.setAttribute('y1', d.startY);
      line.setAttribute('x2', d.endX);
      line.setAttribute('y2', d.endY);
      line.setAttribute('stroke', 'var(--accent)');
      line.setAttribute('stroke-width', 2);
      line.setAttribute('stroke-dasharray', '6 3');
      if (d.type === 'arrow' || d.type === 'connector') {
        line.setAttribute('marker-end', 'url(#arrow-end-accent)');
      }
      g.appendChild(line);
    } else if (d.type === 'text') {
      const rect = document.createElementNS(SVG_NS, 'rect');
      rect.setAttribute('x', d.x);
      rect.setAttribute('y', d.y);
      rect.setAttribute('width', Math.max(d.width, 120));
      rect.setAttribute('height', Math.max(d.height, 32));
      rect.setAttribute('fill', 'none');
      rect.setAttribute('stroke', 'var(--accent)');
      rect.setAttribute('stroke-width', 1);
      rect.setAttribute('stroke-dasharray', '4 3');
      g.appendChild(rect);
    }
  },

  renderRubberBand() {
    const g = document.getElementById('canvas-selection');
    // Remove existing rubber band
    const existing = g.querySelector('.rubber-band');
    if (existing) existing.remove();
    if (!this.rubberBand) return;
    const rb = this.rubberBand;
    const rect = document.createElementNS(SVG_NS, 'rect');
    rect.setAttribute('x', rb.x);
    rect.setAttribute('y', rb.y);
    rect.setAttribute('width', rb.w);
    rect.setAttribute('height', rb.h);
    rect.setAttribute('class', 'selection-box rubber-band');
    g.appendChild(rect);
  },

  clearOverlay() {
    document.getElementById('canvas-overlay').innerHTML = '';
  },

  // ─── Minimap ─────────────────────────────────────────────
  updateMinimap() {
    const svg = document.getElementById('minimap-svg');
    if (!svg) return;
    svg.innerHTML = '';
    if (this.elements.length === 0) return;

    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    this.elements.forEach(el => {
      const b = this.getElementBounds(el);
      minX = Math.min(minX, b.x);
      minY = Math.min(minY, b.y);
      maxX = Math.max(maxX, b.x + b.w);
      maxY = Math.max(maxY, b.y + b.h);
    });

    const pad = 40;
    const totalW = maxX - minX + pad * 2;
    const totalH = maxY - minY + pad * 2;
    svg.setAttribute('viewBox', `${minX - pad} ${minY - pad} ${totalW} ${totalH}`);

    // Draw elements as tiny rects
    this.elements.forEach(el => {
      if (el.type === 'freehand') return;
      const b = this.getElementBounds(el);
      const r = document.createElementNS(SVG_NS, 'rect');
      r.setAttribute('x', b.x);
      r.setAttribute('y', b.y);
      r.setAttribute('width', Math.max(b.w, 4));
      r.setAttribute('height', Math.max(b.h, 4));
      r.setAttribute('fill', el.fill || el.stroke || '#71717a');
      r.setAttribute('rx', 1);
      r.setAttribute('opacity', '0.6');
      svg.appendChild(r);
    });

    // Viewport indicator
    const mainSvg = document.getElementById('svg-canvas');
    const rect = mainSvg.getBoundingClientRect();
    const vw = rect.width / this.viewport.zoom;
    const vh = rect.height / this.viewport.zoom;
    const vr = document.createElementNS(SVG_NS, 'rect');
    vr.setAttribute('x', this.viewport.x);
    vr.setAttribute('y', this.viewport.y);
    vr.setAttribute('width', vw);
    vr.setAttribute('height', vh);
    vr.setAttribute('class', 'mm-viewport');
    svg.appendChild(vr);
  },

  // ─── Keyboard shortcuts ──────────────────────────────────
  _spaceDown: false,

  onKeyDown(e) {
    // Don't capture when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

    if (e.key === ' ') {
      e.preventDefault();
      this._spaceDown = true;
      document.getElementById('canvas-wrap').style.cursor = 'grab';
      return;
    }

    if (e.key === 'Escape') {
      this.selection = [];
      this.drawing = null;
      this.clearOverlay();
      this.render();
      this.closeAllModals();
      this.hidePropsBar();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); this.undo(); return; }
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) { e.preventDefault(); this.redo(); return; }
    if ((e.ctrlKey || e.metaKey) && e.key === 'Z') { e.preventDefault(); this.redo(); return; }

    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (this.selection.length > 0) {
        this.pushUndo();
        this.elements = this.elements.filter(el => !this.selection.includes(el.id));
        this.selection = [];
        this.render();
        this.saveData();
      }
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
      e.preventDefault();
      this.copySelection();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
      e.preventDefault();
      this.pasteClipboard();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
      e.preventDefault();
      this.cutSelection();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'g' && !e.shiftKey) {
      e.preventDefault();
      this.groupSelection();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'g' && e.shiftKey) {
      e.preventDefault();
      this.ungroupSelection();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
      e.preventDefault();
      this.duplicateSelection();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
      e.preventDefault();
      this.selection = this.elements.map(el => el.id);
      this.render();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === '0') {
      e.preventDefault();
      this.fitToScreen();
      return;
    }

    // Tool shortcuts
    const toolMap = {};
    TOOLS.forEach(t => { if (t.key) toolMap[t.key.toLowerCase()] = t.id; });
    if (!e.ctrlKey && !e.metaKey && toolMap[e.key.toLowerCase()]) {
      this.setTool(toolMap[e.key.toLowerCase()]);
    }

    if (e.key === '[' && !e.shiftKey) { this.setPenWidth(Math.max(1, this.penWidth - 1)); document.getElementById('pp-width').value = this.penWidth; this.toast(`Width: ${this.penWidth}px`); }
    if (e.key === ']' && !e.shiftKey) { this.setPenWidth(Math.min(20, this.penWidth + 1)); document.getElementById('pp-width').value = this.penWidth; this.toast(`Width: ${this.penWidth}px`); }
    if (e.key === '{') { this.setPenOpacity(Math.max(0.05, this.penOpacity - 0.1)); this.toast(`Opacity: ${Math.round(this.penOpacity * 100)}%`); }
    if (e.key === '}') { this.setPenOpacity(Math.min(1, this.penOpacity + 0.1)); this.toast(`Opacity: ${Math.round(this.penOpacity * 100)}%`); }
  },

  // ─── Context menu ────────────────────────────────────────
  showContextMenu(e) {
    const p = this.screenToCanvas(e.clientX, e.clientY);
    const hit = this.hitTest(p.x, p.y);
    const menu = document.getElementById('ctx-menu');
    menu.innerHTML = '';

    if (hit) {
      if (!this.selection.includes(hit.id)) this.selection = [hit.id];
      this.render();

      const items = [
        { label: 'Edit', shortcut: 'Dbl-click', action: () => this.editElement(hit.id) },
        { sep: true },
        { label: 'Copy', shortcut: 'Ctrl+C', action: () => this.copySelection() },
        { label: 'Cut', shortcut: 'Ctrl+X', action: () => this.cutSelection() },
        { label: 'Duplicate', shortcut: 'Ctrl+D', action: () => this.duplicateSelection() },
        { label: 'Bring to Front', action: () => this.bringToFront() },
        { label: 'Send to Back', action: () => this.sendToBack() },
      ];
      // Connector routing options
      if (['line', 'arrow', 'connector'].includes(hit.type)) {
        items.push({ sep: true });
        items.push({ label: 'Route: Straight', action: () => { this.pushUndo(); hit.routeType = 'straight'; this.render(); this.saveData(); } });
        items.push({ label: 'Route: Elbow', action: () => { this.pushUndo(); hit.routeType = 'elbow'; this.render(); this.saveData(); } });
        items.push({ label: 'Route: Curved', action: () => { this.pushUndo(); hit.routeType = 'curved'; this.render(); this.saveData(); } });
      }
      // Layer assignment
      if (this.layers.length > 1) {
        items.push({ sep: true });
        this.layers.forEach(l => {
          items.push({ label: `→ Layer: ${l.name}`, action: () => { this.pushUndo(); this.getSelectedElements().forEach(el => el.layerId = l.id); this.render(); this.saveData(); } });
        });
      }
      items.push({ sep: true });
      items.push({ label: hit.locked ? 'Unlock' : 'Lock', action: () => { this.pushUndo(); hit.locked = !hit.locked; this.render(); this.saveData(); this.toast(hit.locked ? 'Locked' : 'Unlocked'); } });
      items.push(
        { label: 'Delete', shortcut: 'Del', cls: 'danger', action: () => { this.pushUndo(); this.elements = this.elements.filter(el => !this.selection.includes(el.id)); this.selection = []; this.render(); this.saveData(); } },
      );
      items.forEach(item => {
        if (item.sep) { const s = document.createElement('div'); s.className = 'ctx-sep'; menu.appendChild(s); return; }
        const div = document.createElement('div');
        div.className = 'ctx-item' + (item.cls ? ' ' + item.cls : '');
        div.innerHTML = `${item.label}${item.shortcut ? '<span class="shortcut">' + item.shortcut + '</span>' : ''}`;
        div.onclick = () => { item.action(); this.hideContextMenu(); };
        menu.appendChild(div);
      });
    } else {
      const items = [
        { label: 'Paste', shortcut: 'Ctrl+V', action: () => this.pasteClipboard() },
        { label: 'Select All', shortcut: 'Ctrl+A', action: () => { this.selection = this.elements.map(el => el.id); this.render(); } },
        { sep: true },
        { label: 'Fit to Screen', shortcut: 'Ctrl+0', action: () => this.fitToScreen() },
        { label: 'Reset Zoom', action: () => { this.viewport.zoom = 1; this.updateViewBox(); } },
        { sep: true },
        { label: 'Toggle Grid', action: () => { this.snapToGrid = !this.snapToGrid; this.toast(this.snapToGrid ? 'Grid: On' : 'Grid: Off'); } },
      ];
      items.forEach(item => {
        if (item.sep) { const s = document.createElement('div'); s.className = 'ctx-sep'; menu.appendChild(s); return; }
        const div = document.createElement('div');
        div.className = 'ctx-item';
        div.innerHTML = `${item.label}${item.shortcut ? '<span class="shortcut">' + item.shortcut + '</span>' : ''}`;
        div.onclick = () => { item.action(); this.hideContextMenu(); };
        menu.appendChild(div);
      });
    }

    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.classList.add('show');
  },

  hideContextMenu() {
    document.getElementById('ctx-menu').classList.remove('show');
  },

  // ─── Element editing ─────────────────────────────────────
  onDblClick(e) {
    const p = this.screenToCanvas(e.clientX, e.clientY);
    const hit = this.hitTest(p.x, p.y);
    if (hit) this.editElement(hit.id);
  },

  editElement(id) {
    const el = this.elements.find(e => e.id === id);
    if (!el) return;
    this._editingId = id;
    document.getElementById('edit-text').value = el.text || '';
    document.getElementById('edit-type').value = el.type;
    document.getElementById('edit-fill').value = el.fill || this._themeBg2();
    document.getElementById('edit-stroke').value = el.stroke || this._themeAccent();
    this.openModal('modal-edit');
  },

  saveEdit() {
    const el = this.elements.find(e => e.id === this._editingId);
    if (!el) return;
    this.pushUndo();
    el.text = document.getElementById('edit-text').value;
    el.fill = document.getElementById('edit-fill').value;
    el.stroke = document.getElementById('edit-stroke').value;
    const newType = document.getElementById('edit-type').value;
    if (newType !== el.type && !['line', 'arrow', 'connector', 'freehand'].includes(el.type)) {
      el.type = newType;
    }
    this.closeModal('modal-edit');
    this.render();
    this.saveData();
  },

  // ─── Properties bar ──────────────────────────────────────
  showPropsBar() {
    const sel = this.getSelectedElements();
    if (sel.length === 0) return;
    const el = sel[0];
    const isSym = el.type === 'engineering-block';
    // Show/hide prop groups based on element type
    document.getElementById('pg-fill').style.display = isSym ? 'none' : '';
    document.getElementById('pg-opacity').style.display = isSym ? 'none' : '';
    document.getElementById('pg-icon-size').style.display = isSym ? '' : 'none';
    // Sync values
    if (!isSym) {
      document.getElementById('prop-fill').value = el.fill || this._themeBg2();
      document.getElementById('prop-opacity').value = el.opacity || 1;
    }
    document.getElementById('prop-stroke').value = el.stroke || this._themeAccent();
    document.getElementById('prop-stroke-width').value = el.strokeWidth || 2;
    document.getElementById('prop-font-size').value = el.fontSize || 14;
    if (isSym) {
      const sc = el.iconScale || 1;
      document.getElementById('prop-icon-scale').value = sc;
      document.getElementById('prop-icon-scale-val').textContent = sc + '×';
    }
    document.getElementById('props-bar').classList.add('show');
  },

  hidePropsBar() {
    document.getElementById('props-bar').classList.remove('show');
  },

  setProp(prop, val) {
    const sel = this.getSelectedElements();
    if (sel.length === 0) return;
    this.pushUndo();
    sel.forEach(el => {
      // Symbols: fill and opacity are locked
      if (el.type === 'engineering-block' && (prop === 'fill' || prop === 'opacity')) return;
      el[prop] = val;
    });
    // Update icon scale display
    if (prop === 'iconScale') {
      document.getElementById('prop-icon-scale-val').textContent = val + '×';
    }
    this.render();
    this.saveData();
  },

  // ─── Element operations ──────────────────────────────────
  duplicateSelection() {
    const sel = this.getSelectedElements();
    if (sel.length === 0) return;
    this.pushUndo();
    const newIds = [];
    sel.forEach(el => {
      const copy = JSON.parse(JSON.stringify(el));
      copy.id = uid();
      copy.x += 20;
      copy.y += 20;
      if (copy.x2 !== undefined) { copy.x2 += 20; copy.y2 += 20; }
      this.elements.push(copy);
      newIds.push(copy.id);
    });
    this.selection = newIds;
    this.render();
    this.saveData();
  },

  bringToFront() {
    const sel = this.getSelectedElements();
    sel.forEach(el => {
      const idx = this.elements.indexOf(el);
      if (idx >= 0) { this.elements.splice(idx, 1); this.elements.push(el); }
    });
    this.render();
    this.saveData();
  },

  sendToBack() {
    const sel = this.getSelectedElements();
    sel.reverse().forEach(el => {
      const idx = this.elements.indexOf(el);
      if (idx >= 0) { this.elements.splice(idx, 1); this.elements.unshift(el); }
    });
    this.render();
    this.saveData();
  },

  groupSelection() {
    const sel = this.getSelectedElements();
    if (sel.length < 2) return;
    this.pushUndo();
    const gid = 'grp-' + uid();
    sel.forEach(el => { el.groupId = gid; });
    this.toast(`Grouped ${sel.length} elements`);
    this.saveData();
  },

  ungroupSelection() {
    const sel = this.getSelectedElements();
    const groups = [...new Set(sel.map(el => el.groupId).filter(Boolean))];
    if (groups.length === 0) return;
    this.pushUndo();
    this.elements.forEach(el => { if (groups.includes(el.groupId)) el.groupId = null; });
    this.toast('Ungrouped');
    this.saveData();
  },

  // ─── Board management ────────────────────────────────────
  renameBoard() {
    const b = this.getActiveBoard();
    if (!b) return;
    const name = prompt('Board name:', b.name);
    if (name && name.trim()) {
      b.name = name.trim();
      document.getElementById('board-name').textContent = b.name;
      this.saveData();
    }
  },

  showNewBoardModal() {
    document.getElementById('new-board-name').value = '';
    document.getElementById('new-board-template').value = 'blank';
    this.openModal('modal-new-board');
  },

  createNewBoard() {
    const name = document.getElementById('new-board-name').value.trim() || 'Untitled Board';
    const template = document.getElementById('new-board-template').value;
    const elements = this.getTemplateElements(template);
    const board = this.makeBoard(name, elements);
    this.boards.push(board);
    this.closeModal('modal-new-board');
    this.switchBoard(board.id);
    this.fitToScreen();
    this.toast(`Created: ${name}`);
  },

  // ─── Templates ───────────────────────────────────────────
  getTemplateElements(template) {
    if (template === 'blank') return [];

    if (template === 'block-diagram') {
      return [
        { id: uid(), type: 'rectangle', x: 300, y: 100, width: 200, height: 80, fill: '#1e3a5f', stroke: '#3b82f6', strokeWidth: 2, text: 'System', fontSize: 16, textAlign: 'center', opacity: 1, locked: false },
        { id: uid(), type: 'rectangle', x: 100, y: 280, width: 160, height: 60, fill: '#292524', stroke: '#f59e0b', strokeWidth: 2, text: 'Subsystem A', fontSize: 13, textAlign: 'center', opacity: 1, locked: false },
        { id: uid(), type: 'rectangle', x: 320, y: 280, width: 160, height: 60, fill: '#292524', stroke: '#f59e0b', strokeWidth: 2, text: 'Subsystem B', fontSize: 13, textAlign: 'center', opacity: 1, locked: false },
        { id: uid(), type: 'rectangle', x: 540, y: 280, width: 160, height: 60, fill: '#292524', stroke: '#f59e0b', strokeWidth: 2, text: 'Subsystem C', fontSize: 13, textAlign: 'center', opacity: 1, locked: false },
      ];
    }

    if (template === 'fishbone') {
      const els = [];
      // Spine
      els.push({ id: uid(), type: 'arrow', x: 100, y: 300, x2: 700, y2: 300, stroke: '#f59e0b', strokeWidth: 3, opacity: 1, locked: false, text: '' });
      // Head (effect)
      els.push({ id: uid(), type: 'rectangle', x: 700, y: 265, width: 160, height: 70, fill: '#3b1a1a', stroke: '#ef4444', strokeWidth: 2, text: 'Problem / Effect', fontSize: 13, textAlign: 'center', opacity: 1, locked: false });
      // Ribs
      const cats = ['Method', 'Machine', 'Material', 'Measurement', 'Man', 'Environment'];
      cats.forEach((cat, i) => {
        const baseX = 180 + i * 85;
        const topY = i % 2 === 0 ? 180 : 400;
        els.push({ id: uid(), type: 'line', x: baseX, y: topY, x2: baseX + 40, y2: 300, stroke: '#71717a', strokeWidth: 2, opacity: 1, locked: false, text: '' });
        els.push({ id: uid(), type: 'text', x: baseX - 30, y: i % 2 === 0 ? 150 : 410, width: 100, height: 28, fill: 'transparent', stroke: 'transparent', strokeWidth: 0, text: cat, fontSize: 12, textAlign: 'center', opacity: 1, locked: false });
      });
      return els;
    }

    if (template === 'retrospective') {
      const cols = [
        { title: 'Went Well', color: '#34d399', x: 60 },
        { title: 'Improve', color: '#fbbf24', x: 320 },
        { title: 'Actions', color: '#60a5fa', x: 580 },
      ];
      const els = [];
      cols.forEach(col => {
        els.push({ id: uid(), type: 'text', x: col.x, y: 40, width: 220, height: 36, fill: 'transparent', stroke: 'transparent', strokeWidth: 0, text: col.title, fontSize: 18, textAlign: 'center', opacity: 1, locked: false });
        // Add 2 sample stickies
        for (let r = 0; r < 2; r++) {
          els.push({ id: uid(), type: 'sticky', x: col.x, y: 100 + r * 140, width: 220, height: 110, fill: col.color, stroke: 'transparent', strokeWidth: 0, text: 'Add your note...', fontSize: 14, textAlign: 'center', opacity: 1, locked: false });
        }
      });
      return els;
    }

    if (template === 'kanban') {
      const lanes = ['To Do', 'In Progress', 'Review', 'Done'];
      const els = [];
      lanes.forEach((lane, i) => {
        els.push({ id: uid(), type: 'rectangle', x: 20 + i * 230, y: 40, width: 210, height: 500, fill: 'rgba(39,39,42,.5)', stroke: '#3f3f46', strokeWidth: 1, text: '', fontSize: 14, textAlign: 'center', opacity: 1, locked: true });
        els.push({ id: uid(), type: 'text', x: 20 + i * 230, y: 50, width: 210, height: 30, fill: 'transparent', stroke: 'transparent', strokeWidth: 0, text: lane, fontSize: 15, textAlign: 'center', opacity: 1, locked: false });
      });
      return els;
    }

    return [];
  },

  // ─── Export / Import ─────────────────────────────────────
  exportJSON() {
    const b = this.getActiveBoard();
    if (!b) return;
    b.elements = JSON.parse(JSON.stringify(this.elements));
    const json = JSON.stringify(b, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (b.name || 'board').replace(/\s+/g, '-').toLowerCase() + '.json';
    a.click();
    URL.revokeObjectURL(url);
    this.toast('Exported JSON');
  },

  importJSON() {
    document.getElementById('file-input').click();
  },

  handleImport(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        const board = this.makeBoard(data.name || 'Imported Board', data.elements || []);
        this.boards.push(board);
        this.switchBoard(board.id);
        this.fitToScreen();
        this.toast('Imported board');
      } catch(err) { this.toast('Import failed: ' + err.message); }
    };
    reader.readAsText(file);
    e.target.value = '';
  },

  exportPNG() {
    // Create a temporary SVG for export
    const svg = document.getElementById('svg-canvas');
    const clone = svg.cloneNode(true);
    // Remove selection overlay
    const sel = clone.querySelector('#canvas-selection');
    if (sel) sel.innerHTML = '';
    const overlay = clone.querySelector('#canvas-overlay');
    if (overlay) overlay.innerHTML = '';

    const data = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([data], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (this.getActiveBoard()?.name || 'board') + '.svg';
    a.click();
    URL.revokeObjectURL(url);
    this.toast('Exported SVG');
  },

  // ─── Theme ───────────────────────────────────────────────
  toggleTheme() {
    if (window._bsiIsEmbedded) return;
    const themes = ['dark', 'light', 'eink'];
    const idx = themes.indexOf(this.theme);
    this.theme = themes[(idx + 1) % themes.length];
    document.documentElement.setAttribute('data-theme', this.theme);
    document.documentElement.style.colorScheme = (this.theme === 'light' || this.theme === 'eink') ? 'light' : 'dark';
    localStorage.setItem('fb_theme', this.theme);
    this.toast('Theme: ' + this.theme);
    this.render();
  },

  // ─── Modals ──────────────────────────────────────────────
  openModal(id) { document.getElementById(id).classList.add('show'); },
  closeModal(id) { document.getElementById(id).classList.remove('show'); },
  closeAllModals() {
    document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('show'));
  },

  // ─── Toast ───────────────────────────────────────────────
  toast(msg) {
    const c = document.getElementById('toasts');
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = msg;
    c.appendChild(t);
    setTimeout(() => { t.remove(); }, 3000);
  },

  // ─── Demo mode ───────────────────────────────────────────
  loadDemoData() {
    // Board 1: Interceptor Drone — System Architecture
    const b1Elements = [];
    // Main system block
    b1Elements.push({ id: 'demo-sys', type: 'rectangle', x: 300, y: 60, width: 280, height: 80, fill: '#1e3a5f', stroke: '#3b82f6', strokeWidth: 3, text: 'Interceptor Drone C-UAS\nSystem Architecture', fontSize: 15, textAlign: 'center', opacity: 1, locked: false });

    // Subsystems
    const subs = [
      { name: 'Propulsion', x: 40, color: '#22c55e', sColor: '#166534' },
      { name: 'Guidance &\nNavigation', x: 230, color: '#f59e0b', sColor: '#92400e' },
      { name: 'C2 Datalink', x: 420, color: '#3b82f6', sColor: '#1e3a5f' },
      { name: 'Interceptor\nMechanism', x: 610, color: '#ef4444', sColor: '#7f1d1d' },
      { name: 'Ground Control\nStation', x: 800, color: '#8b5cf6', sColor: '#3b0764' },
    ];
    subs.forEach((s, i) => {
      b1Elements.push({ id: `demo-sub-${i}`, type: 'rectangle', x: s.x, y: 220, width: 160, height: 70, fill: s.sColor, stroke: s.color, strokeWidth: 2, text: s.name, fontSize: 12, textAlign: 'center', opacity: 1, locked: false });
      // Connector from system to subsystem
      b1Elements.push({ id: `demo-conn-${i}`, type: 'arrow', x: 440, y: 140, x2: s.x + 80, y2: 220, stroke: '#71717a', strokeWidth: 1.5, opacity: 0.6, locked: false, text: '' });
    });

    // Functions under Propulsion
    const propFuncs = ['Motor\nControl', 'Power\nDistribution', 'Thermal\nManagement'];
    propFuncs.forEach((f, i) => {
      b1Elements.push({ id: `demo-func-p${i}`, type: 'rectangle', x: 10 + i * 80, y: 360, width: 70, height: 55, fill: '#292524', stroke: '#22c55e', strokeWidth: 1.5, text: f, fontSize: 10, textAlign: 'center', opacity: 1, locked: false });
      b1Elements.push({ id: `demo-pconn-${i}`, type: 'arrow', x: 120, y: 290, x2: 45 + i * 80, y2: 360, stroke: '#22c55e', strokeWidth: 1, opacity: 0.4, locked: false, text: '' });
    });

    // Annotations
    b1Elements.push({ id: 'demo-note1', type: 'sticky', x: 650, y: 360, width: 180, height: 80, fill: '#fbbf24', stroke: 'transparent', strokeWidth: 0, text: 'Verify thrust margin\n>15 kgf @ MTOW', fontSize: 11, textAlign: 'center', opacity: 1, locked: false });
    b1Elements.push({ id: 'demo-note2', type: 'sticky', x: 850, y: 100, width: 160, height: 70, fill: '#f87171', stroke: 'transparent', strokeWidth: 0, text: 'EMI shielding TBD\nREQ-042 open', fontSize: 11, textAlign: 'center', opacity: 1, locked: false });

    // Interface line
    b1Elements.push({ id: 'demo-if1', type: 'connector', x: 200, y: 255, x2: 420, y2: 255, stroke: '#71717a', strokeWidth: 1, opacity: 0.5, locked: false, text: 'Power Bus' });

    const board1 = this.makeBoard('Interceptor Drone — System Architecture', b1Elements);

    // Board 2: Sprint 12 Retrospective
    const b2Elements = [];
    const retroCols = [
      { title: 'Went Well', color: '#34d399', x: 40 },
      { title: 'Needs Improvement', color: '#fbbf24', x: 300 },
      { title: 'Action Items', color: '#60a5fa', x: 560 },
    ];

    retroCols.forEach(col => {
      b2Elements.push({ id: uid(), type: 'text', x: col.x, y: 20, width: 220, height: 36, fill: 'transparent', stroke: 'transparent', strokeWidth: 0, text: col.title, fontSize: 18, textAlign: 'center', opacity: 1, locked: true });
    });

    const notes = [
      { col: 0, y: 80, text: 'CI/CD pipeline reduced\nbuild time by 40%', color: '#34d399' },
      { col: 0, y: 200, text: 'Cross-team collaboration\non GNC module was smooth', color: '#34d399' },
      { col: 0, y: 320, text: 'Test coverage hit 85%\non propulsion firmware', color: '#34d399' },
      { col: 1, y: 80, text: 'Requirements churn on\ninterceptor mechanism spec', color: '#fbbf24' },
      { col: 1, y: 200, text: 'Code review turnaround\ntoo slow (avg 3 days)', color: '#fbbf24' },
      { col: 1, y: 320, text: 'Flaky integration tests\nblocking merges to main', color: '#fbbf24' },
      { col: 2, y: 80, text: 'Set up automated\nreview reminders in Slack', color: '#60a5fa' },
      { col: 2, y: 200, text: 'Dedicate 1 sprint to\ntest infrastructure fixes', color: '#60a5fa' },
      { col: 2, y: 320, text: 'Lock interceptor spec\nbefore Sprint 13 start', color: '#60a5fa' },
    ];

    notes.forEach(n => {
      b2Elements.push({ id: uid(), type: 'sticky', x: retroCols[n.col].x, y: n.y, width: 220, height: 100, fill: n.color, stroke: 'transparent', strokeWidth: 0, text: n.text, fontSize: 12, textAlign: 'center', opacity: 1, locked: false });
    });

    const board2 = this.makeBoard('Sprint 12 — Retrospective', b2Elements);

    this.boards = [board1, board2];
    this.activeBoardId = board1.id;
    this.saveData();
  },

  resetDemo() {
    localStorage.removeItem(this.storageKey('boards'));
    this.boards = [];
    this.elements = [];
    this.loadDemoData();
    this.switchBoard(this.boards[0].id);
    this.fitToScreen();
    this.toast('Demo data reset');
  },

  exitDemo() {
    window.location.href = window.location.pathname;
  },

  // ─── Phase 2: Engineering Symbol Library ─────────────────
  _symbolCategory: 'electrical',
  _symbolFilter: '',

  SYMBOLS: {
    electrical: [
      { name: 'Resistor', path: 'M2 12h4l1-3 2 6 2-6 2 6 2-6 2 6 1-3h4', w: 24, h: 24 },
      { name: 'Capacitor', path: 'M8 4v16M16 4v16M2 12h6M18 12h4', w: 24, h: 24 },
      { name: 'Inductor', path: 'M2 12h2c0-2 2-2 2 0s2 2 2 0 2-2 2 0 2 2 2 0 2-2 2 0h2', w: 24, h: 24 },
      { name: 'Diode', path: 'M2 12h7l0-5 7 5-7 5 0-5M16 7v10M16 12h6', w: 24, h: 24 },
      { name: 'LED', path: 'M2 12h7l0-5 7 5-7 5 0-5M16 7v10M16 12h6M13 4l2-2M16 5l2-2', w: 24, h: 24 },
      { name: 'Zener', path: 'M2 12h7l0-5 7 5-7 5 0-5M14 7l2-1v11l2 1M18 12h4', w: 24, h: 24 },
      { name: 'NPN', path: 'M6 4v16M6 8l8 4M6 16l8-4M14 12l4 6M14 12l4-6', w: 24, h: 24, circle: true },
      { name: 'PNP', path: 'M6 4v16M6 8l8 4M6 16l8-4M14 12l4 6M14 12l4-6', w: 24, h: 24, circle: true },
      { name: 'MOSFET N', path: 'M6 4v16M9 6v12M9 12h9M18 6v12', w: 24, h: 24, circle: true },
      { name: 'Op-Amp', path: 'M4 3v18l16-9-16-9zM4 8h-2M4 16h-2M20 12h2', w: 24, h: 24 },
      { name: 'AND Gate', path: 'M2 4h6a8 8 0 0 1 0 16H2V4zM18 12h4M2 8h-2M2 16h-2', w: 24, h: 24 },
      { name: 'OR Gate', path: 'M2 4q4 8 0 16h4q10-4 14-8-4-4-14-8H2zM20 12h2', w: 24, h: 24 },
      { name: 'NOT Gate', path: 'M4 4v16l12-8-12-8zM16 12a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0M19 12h3M4 12h-2', w: 24, h: 24 },
      { name: 'XOR Gate', path: 'M4 4q4 8 0 16M4 4h2q10 4 14 8-4 4-14 8H4M20 12h2', w: 24, h: 24 },
      { name: 'Ground', path: 'M12 2v8M6 10h12M8 14h8M10 18h4', w: 24, h: 24 },
      { name: 'Battery', path: 'M2 12h6M8 6v12M12 9v6M14 6v12M18 9v6M20 12h2', w: 24, h: 24 },
      { name: 'AC Source', path: 'M2 12h6M16 12h6', w: 24, h: 24, circle: true, extra: 'M8 12q2-4 4 0t4 0' },
      { name: 'Fuse', path: 'M2 12h7M15 12h7M9 8h6v8H9z', w: 24, h: 24, extra: 'M9 12h6' },
      { name: 'Switch', path: 'M2 14h6M22 14h-6M8 14l8-6', w: 24, h: 24 },
      { name: 'Relay', path: 'M2 8h4v8H2zM6 12h4M14 4v16M14 8h4v8h-4M22 8h-4M22 16h-4', w: 24, h: 24 },
      { name: 'Transformer', path: 'M4 4v16M4 6h2q2 0 2 2v0q0 2-2 2h-2M4 10h2q2 0 2 2v0q0 2-2 2h-2M4 14h2q2 0 2 2v0q0 2-2 2h-2M12 4v16M20 4v16M20 6h-2q-2 0-2 2v0q0 2 2 2h2M20 10h-2q-2 0-2 2v0q0 2 2 2h2M20 14h-2q-2 0-2 2v0q0 2 2 2h2', w: 24, h: 24 },
      { name: 'Antenna', path: 'M12 14V22M4 2l8 12L20 2', w: 24, h: 24 },
      { name: 'Crystal', path: 'M2 12h5M17 12h5M7 6v12M17 6v12M9 8h6v8H9z', w: 24, h: 24 },
    ],
    mechanical: [
      { name: 'Bearing', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0-6 0', w: 24, h: 24 },
      { name: 'Spur Gear', path: 'M12 12m-7 0a7 7 0 1 0 14 0a7 7 0 1 0-14 0M12 12m-2 0a2 2 0 1 0 4 0a2 2 0 1 0-4 0M12 2v3M12 19v3M2 12h3M19 12h3M4.93 4.93l2.12 2.12M16.95 16.95l2.12 2.12M4.93 19.07l2.12-2.12M16.95 7.05l2.12-2.12', w: 24, h: 24 },
      { name: 'Spring', path: 'M12 2v2M12 20v2M8 4h8l-6 2.67 8 2.66-8 2.67 8 2.67-8 2.66L16 20H8', w: 24, h: 24 },
      { name: 'Damper', path: 'M12 2v4M12 18v4M8 6h8M8 6v12h8V6M10 10h4M10 14h4', w: 24, h: 24 },
      { name: 'Shaft', path: 'M2 10h20v4H2z', w: 24, h: 24, extra: 'M6 10v4M18 10v4' },
      { name: 'Coupling', path: 'M2 10h8v4H2zM14 10h8v4h-8zM10 8v8M14 8v8', w: 24, h: 24 },
      { name: 'Belt Pulley', path: 'M6 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0-8 0M18 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0-8 0M10 10h4M10 14h4', w: 24, h: 24 },
      { name: 'Bolt', path: 'M12 2L8 6h8l-4-4zM10 6v14M14 6v14M8 20h8', w: 24, h: 24 },
      { name: 'Fixed Support', path: 'M4 18h16M6 18l-2 4M10 18l-2 4M14 18l-2 4M18 18l-2 4M12 4v14', w: 24, h: 24 },
      { name: 'Roller Support', path: 'M12 14m-4 0a4 4 0 1 0 8 0a4 4 0 1 0-8 0M4 18h16M12 4v6', w: 24, h: 24 },
      { name: 'Pinned Joint', path: 'M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0-6 0M4 18h16M6 18l-2 4M10 18l-2 4M14 18l-2 4M18 18l-2 4M12 15v3', w: 24, h: 24 },
      { name: 'Force Arrow', path: 'M12 20V4M8 8l4-4 4 4', w: 24, h: 24 },
      { name: 'Moment', path: 'M12 12m-6 0a6 6 0 0 1 10.39-3.46M18 6l-1.61 2.54', w: 24, h: 24 },
      { name: 'Dist. Load', path: 'M2 20h20M4 20v-8M8 20v-12M12 20v-14M16 20v-12M20 20v-8M4 12l16-2', w: 24, h: 24 },
    ],
    process: [
      { name: 'Gate Valve', path: 'M4 4l8 8M20 4l-8 8M4 20l8-8M20 20l-8-8M12 2v4M12 18v4', w: 24, h: 24 },
      { name: 'Globe Valve', path: 'M4 4l8 8M20 4l-8 8M4 20l8-8M20 20l-8-8M12 2v4M12 18v4', w: 24, h: 24, circle: true },
      { name: 'Ball Valve', path: 'M2 12h6M16 12h6M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0-8 0', w: 24, h: 24 },
      { name: 'Check Valve', path: 'M2 12h6M16 12h6M8 4v16M8 12l8-8v16l-8-8', w: 24, h: 24 },
      { name: 'Butterfly', path: 'M2 12h6M16 12h6M8 4l8 16M8 20l8-16', w: 24, h: 24, circle: true },
      { name: 'Solenoid Valve', path: 'M4 4l8 8-8 8M20 4l-8 8 8 8M12 2v4M12 18v4M2 2h8v4H2z', w: 24, h: 24 },
      { name: 'Pump', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0M2 12h4M20 12h2M12 4l6 8', w: 24, h: 24 },
      { name: 'Compressor', path: 'M4 4v16l16-8-16-8zM20 12h2M2 12h2', w: 24, h: 24 },
      { name: 'Heat Exchanger', path: 'M4 4v16h16V4H4zM2 8h4M2 16h4M20 12h2', w: 24, h: 24, extra: 'M7 8h10M7 12h10M7 16h10' },
      { name: 'Tank', path: 'M6 4q0-2 6-2t6 2v16q0 2-6 2t-6-2V4z', w: 24, h: 24, extra: 'M6 10h12' },
      { name: 'Filter', path: 'M4 4l8 10v6l-2 2h12l-2-2v-6l8-10H4z', w: 24, h: 24 },
      { name: 'Temp Sensor', path: 'M12 12m-6 0a6 6 0 1 0 12 0a6 6 0 1 0-12 0', w: 24, h: 24, label: 'TI' },
      { name: 'Pressure', path: 'M12 12m-6 0a6 6 0 1 0 12 0a6 6 0 1 0-12 0', w: 24, h: 24, label: 'PI' },
      { name: 'Flow Sensor', path: 'M12 12m-6 0a6 6 0 1 0 12 0a6 6 0 1 0-12 0', w: 24, h: 24, label: 'FI' },
      { name: 'Level Sensor', path: 'M12 12m-6 0a6 6 0 1 0 12 0a6 6 0 1 0-12 0', w: 24, h: 24, label: 'LI' },
      { name: 'PID Controller', path: 'M4 4h16v16H4z', w: 24, h: 24, label: 'PID' },
      { name: 'PLC', path: 'M4 4h16v16H4z', w: 24, h: 24, label: 'PLC' },
    ],
    systems: [
      { name: 'Func. Block', path: 'M3 3h18v18H3z', w: 24, h: 24, extra: 'M3 9h18M3 15h18M9 3v6M15 3v6', label: 'F' },
      { name: 'Interface', path: 'M3 3h18v18H3z', w: 24, h: 24, dasharray: '4 2' },
      { name: 'System Boundary', path: 'M2 2h20v20H2z', w: 24, h: 24, dasharray: '6 3' },
      { name: 'Data Store', path: 'M4 6h16M4 6v12h16V6M4 6h0', w: 24, h: 24 },
      { name: 'Process', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0', w: 24, h: 24 },
      { name: 'External Entity', path: 'M3 3h18v18H3zM5 5h14v14H5z', w: 24, h: 24 },
      { name: 'Decision', path: 'M12 2l10 10-10 10L2 12z', w: 24, h: 24 },
      { name: 'Start/End', path: 'M7 4h10a7 7 0 0 1 0 16H7a7 7 0 0 1 0-16z', w: 24, h: 24 },
      { name: 'Swimlane', path: 'M2 2h20v20H2zM2 8h20', w: 24, h: 24, extra: 'M2 14h20' },
      { name: 'AND (Fault)', path: 'M4 12h16M4 12a8 8 0 0 0 16 0', w: 24, h: 24 },
      { name: 'OR (Fault)', path: 'M4 14q8-12 16 0M4 14q8 8 16 0', w: 24, h: 24 },
      { name: 'Basic Event', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0', w: 24, h: 24 },
      { name: 'Transfer', path: 'M12 2l10 18H2z', w: 24, h: 24 },
    ],
    annotations: [
      { name: 'Callout', path: 'M4 4h16v12H10l-4 4v-4H4V4z', w: 24, h: 24 },
      { name: 'Cloud', path: 'M6 18a4 4 0 0 1-.88-7.9A6 6 0 0 1 17 8a5 5 0 0 1 1 9.9', w: 24, h: 24 },
      { name: 'Dimension', path: 'M2 16h20M2 14v4M22 14v4M12 12v4', w: 24, h: 24, label: '100' },
      { name: 'Leader Line', path: 'M2 12h12l4-8', w: 24, h: 24, extra: 'M16 4l2 0 0 2' },
      { name: 'Section Mark', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0', w: 24, h: 24, label: 'A' },
      { name: 'Rev. Triangle', path: 'M12 4l8 16H4z', w: 24, h: 24, label: 'R1' },
      { name: 'Checkmark', path: 'M4 12l5 6L20 6', w: 24, h: 24 },
      { name: 'Cross Mark', path: 'M6 6l12 12M18 6L6 18', w: 24, h: 24 },
      { name: 'Warning', path: 'M12 2L2 22h20L12 2zM12 9v6M12 18v.01', w: 24, h: 24 },
      { name: 'Info', path: 'M12 12m-10 0a10 10 0 1 0 20 0a10 10 0 1 0-20 0M12 8v.01M12 12v5', w: 24, h: 24 },
      { name: 'Status Green', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0', w: 24, h: 24, fillColor: '#22c55e' },
      { name: 'Status Amber', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0', w: 24, h: 24, fillColor: '#f59e0b' },
      { name: 'Status Red', path: 'M12 12m-8 0a8 8 0 1 0 16 0a8 8 0 1 0-16 0', w: 24, h: 24, fillColor: '#ef4444' },
    ]
  },

  initSymbolPanel() {
    const tabs = document.getElementById('symbol-tabs');
    const cats = Object.keys(this.SYMBOLS);
    tabs.innerHTML = cats.map(c => `<button class="sp-tab${c === this._symbolCategory ? ' active' : ''}" onclick="app.setSymbolCategory('${c}')">${c[0].toUpperCase() + c.slice(1)}</button>`).join('');
    this.renderSymbols();
  },

  initPanelResize() {
    const handle = document.getElementById('symbol-resize');
    if (!handle) return;
    const panel = document.getElementById('symbol-panel');
    let startX, startW;
    const onMove = (e) => {
      const newW = Math.max(180, Math.min(window.innerWidth * 0.5, startW + (e.clientX - startX)));
      panel.style.width = newW + 'px';
      // Update grid columns based on width
      const grid = document.getElementById('symbol-grid');
      if (grid) grid.style.gridTemplateColumns = `repeat(${newW < 220 ? 2 : newW < 380 ? 3 : 4}, 1fr)`;
    };
    const onUp = () => {
      handle.classList.remove('active');
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    };
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      startX = e.clientX;
      startW = panel.offsetWidth;
      handle.classList.add('active');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  },

  setSymbolCategory(cat) {
    this._symbolCategory = cat;
    document.querySelectorAll('.sp-tab').forEach(t => t.classList.toggle('active', t.textContent.toLowerCase() === cat));
    this.renderSymbols();
  },

  filterSymbols(q) {
    this._symbolFilter = q.toLowerCase();
    this.renderSymbols();
  },

  renderSymbols() {
    const grid = document.getElementById('symbol-grid');
    let symbols = this.SYMBOLS[this._symbolCategory] || [];
    if (this._symbolFilter) {
      symbols = Object.values(this.SYMBOLS).flat().filter(s => s.name.toLowerCase().includes(this._symbolFilter));
    }
    grid.innerHTML = symbols.map((s, i) => {
      const fill = s.fillColor || 'none';
      const dash = s.dasharray ? ` stroke-dasharray="${s.dasharray}"` : '';
      let svg = `<svg viewBox="0 0 24 24" fill="${fill}" stroke="var(--fg)" stroke-width="1.5"${dash}><path d="${s.path}"/>`;
      if (s.circle) svg += `<circle cx="12" cy="12" r="10" fill="none"/>`;
      if (s.extra) svg += `<path d="${s.extra}"/>`;
      if (s.label) svg += `<text x="12" y="14" text-anchor="middle" font-size="6" fill="var(--fg)" stroke="none">${s.label}</text>`;
      svg += '</svg>';
      return `<div class="sp-item" draggable="true" ondragstart="app.dragSymbol(event,${i},'${this._symbolCategory}')" onclick="app.placeSymbol('${this._symbolCategory}',${i})" title="${s.name}">${svg}<span>${s.name}</span></div>`;
    }).join('');
  },

  toggleSymbolPanel() {
    const p = document.getElementById('symbol-panel');
    const show = !p.classList.contains('show');
    p.classList.toggle('show', show);
    if (show) this.initSymbolPanel();
  },

  dragSymbol(e, idx, cat) {
    e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'symbol', cat, idx }));
  },

  placeSymbol(cat, idx) {
    const symbols = this.SYMBOLS[cat];
    if (!symbols || !symbols[idx]) return;
    const s = symbols[idx];
    this.pushUndo();
    const el = this.createElement('engineering-block', this.viewport.x + 200, this.viewport.y + 200, 120, 80);
    el.text = s.name;
    el.symbolPath = s.path;
    el.symbolExtra = s.extra || '';
    el.symbolLabel = s.label || '';
    el.symbolCircle = s.circle || false;
    el.symbolFill = s.fillColor || '';
    el.symbolDash = s.dasharray || '';
    el.opacity = 1;
    el.iconScale = 1;
    this.elements.push(el);
    this.selection = [el.id];
    this.render();
    this.saveData();
    this.toast(`Placed: ${s.name}`);
  },

  // ─── Phase 2: Layers ───────────────────────────────────────
  layers: [
    { id: 'layer-bg', name: 'Background', visible: true, locked: false },
    { id: 'layer-main', name: 'Diagram', visible: true, locked: false },
    { id: 'layer-ann', name: 'Annotations', visible: true, locked: false },
  ],
  activeLayerId: 'layer-main',

  toggleLayers() {
    document.getElementById('layers-panel').classList.toggle('show');
    this.renderLayers();
  },

  renderLayers() {
    const list = document.getElementById('layers-list');
    list.innerHTML = this.layers.map(l => {
      const eyeIcon = l.visible
        ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>'
        : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19"/><line x1="1" y1="1" x2="23" y2="23"/></svg>';
      const lockIcon = l.locked
        ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>'
        : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>';
      return `<div class="lp-layer${l.id === this.activeLayerId ? ' active' : ''}" onclick="app.setActiveLayer('${l.id}')">
        <span class="lp-icon${l.visible ? '' : ' off'}" onclick="event.stopPropagation();app.toggleLayerVisibility('${l.id}')">${eyeIcon}</span>
        <span class="lp-name">${l.name}</span>
        <span class="lp-icon${l.locked ? '' : ' off'}" onclick="event.stopPropagation();app.toggleLayerLock('${l.id}')">${lockIcon}</span>
      </div>`;
    }).join('');
  },

  addLayer() {
    const name = 'Layer ' + (this.layers.length + 1);
    const id = 'layer-' + uid();
    this.layers.push({ id, name, visible: true, locked: false });
    this.activeLayerId = id;
    this.renderLayers();
  },

  setActiveLayer(id) {
    this.activeLayerId = id;
    this.renderLayers();
  },

  toggleLayerVisibility(id) {
    const l = this.layers.find(l => l.id === id);
    if (l) { l.visible = !l.visible; this.renderLayers(); this.render(); }
  },

  toggleLayerLock(id) {
    const l = this.layers.find(l => l.id === id);
    if (l) { l.locked = !l.locked; this.renderLayers(); }
  },

  // ─── Phase 2: Connector Routing (elbow, curved) ────────────
  connectorRouteType: 'straight',

  renderConnectorPath(el) {
    const route = el.routeType || this.connectorRouteType || 'straight';
    const x1 = el.x, y1 = el.y, x2 = el.x2, y2 = el.y2;
    if (route === 'elbow') {
      const mx = (x1 + x2) / 2;
      return `M${x1},${y1} L${mx},${y1} L${mx},${y2} L${x2},${y2}`;
    } else if (route === 'curved') {
      const dx = Math.abs(x2 - x1) * 0.5;
      return `M${x1},${y1} C${x1 + dx},${y1} ${x2 - dx},${y2} ${x2},${y2}`;
    }
    return `M${x1},${y1} L${x2},${y2}`;
  },

  // ─── Phase 2: Lasso Select ─────────────────────────────────
  lassoPoints: [],
  lassoActive: false,

  startLasso(x, y) {
    this.lassoActive = true;
    this.lassoPoints = [{ x, y }];
  },

  updateLasso(x, y) {
    if (!this.lassoActive) return;
    this.lassoPoints.push({ x, y });
    this.renderLassoPath();
  },

  endLasso() {
    if (!this.lassoActive) return;
    this.lassoActive = false;
    // Find elements inside lasso polygon
    const selected = this.elements.filter(el => {
      const b = this.getElementBounds(el);
      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;
      return this.pointInPolygon(cx, cy, this.lassoPoints);
    });
    this.selection = selected.map(el => el.id);
    this.clearLasso();
    this.render();
    if (this.selection.length > 0) this.showPropsBar();
  },

  pointInPolygon(x, y, pts) {
    let inside = false;
    for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
      const xi = pts[i].x, yi = pts[i].y;
      const xj = pts[j].x, yj = pts[j].y;
      if ((yi > y) !== (yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi) inside = !inside;
    }
    return inside;
  },

  renderLassoPath() {
    const overlay = document.getElementById('canvas-overlay');
    const existing = overlay.querySelector('.lasso-path');
    if (existing) existing.remove();
    if (this.lassoPoints.length < 2) return;
    const d = 'M' + this.lassoPoints.map(p => `${p.x},${p.y}`).join('L') + 'Z';
    const path = document.createElementNS(SVG_NS, 'path');
    path.setAttribute('d', d);
    path.setAttribute('class', 'lasso-path');
    overlay.appendChild(path);
  },

  clearLasso() {
    this.lassoPoints = [];
    const overlay = document.getElementById('canvas-overlay');
    const existing = overlay.querySelector('.lasso-path');
    if (existing) existing.remove();
  },

  // ─── Phase 2: Clipboard Copy/Paste ─────────────────────────
  _clipboard: [],

  copySelection() {
    const sel = this.getSelectedElements();
    if (sel.length === 0) return;
    this._clipboard = JSON.parse(JSON.stringify(sel));
    this.toast(`Copied ${sel.length} element${sel.length > 1 ? 's' : ''}`);
  },

  pasteClipboard() {
    if (this._clipboard.length === 0) return;
    this.pushUndo();
    const newIds = [];
    this._clipboard.forEach(el => {
      const copy = JSON.parse(JSON.stringify(el));
      copy.id = uid();
      copy.x += 30;
      copy.y += 30;
      if (copy.x2 !== undefined) { copy.x2 += 30; copy.y2 += 30; }
      this.elements.push(copy);
      newIds.push(copy.id);
    });
    this.selection = newIds;
    // Update clipboard positions for next paste
    this._clipboard.forEach(el => { el.x += 30; el.y += 30; if (el.x2 !== undefined) { el.x2 += 30; el.y2 += 30; } });
    this.render();
    this.saveData();
    this.toast(`Pasted ${newIds.length} element${newIds.length > 1 ? 's' : ''}`);
  },

  cutSelection() {
    this.copySelection();
    if (this.selection.length > 0) {
      this.pushUndo();
      this.elements = this.elements.filter(el => !this.selection.includes(el.id));
      this.selection = [];
      this.render();
      this.saveData();
    }
  },

  // ─── Phase 2: E-ink Incremental Rendering ──────────────────
  _isEink: false,
  _lastRenderHash: '',

  detectEink() {
    const ua = navigator.userAgent || '';
    this._isEink = ua.includes('BOOX') || window.matchMedia('(update: slow)').matches;
    return this._isEink;
  },

  renderIncremental(changedIds) {
    if (!this._isEink || !changedIds || changedIds.length === 0) {
      this.render();
      return;
    }
    // Only update changed elements instead of full re-render
    changedIds.forEach(id => {
      const el = this.elements.find(e => e.id === id);
      if (!el) return;
      const existing = document.querySelector(`[data-id="${id}"]`);
      if (existing) existing.remove();
      // Re-render just this element
      const g = document.getElementById('canvas-elements');
      const cg = document.getElementById('canvas-connectors');
      if (['line', 'arrow', 'connector'].includes(el.type)) {
        this.renderLine(cg, el);
      } else if (el.type !== 'freehand') {
        this.renderSingleElement(g, el);
      }
    });
    this.updateMinimap();
  },

  renderSingleElement(container, el) {
    // Delegate to renderElements for a single element
    // We'll inline the element rendering logic here for incremental updates
    const group = document.createElementNS(SVG_NS, 'g');
    group.setAttribute('data-id', el.id);
    group.style.opacity = el.opacity || 1;
    if (el.type === 'rectangle' || el.type === 'engineering-block') {
      const isSymbol = el.type === 'engineering-block';
      const rect = document.createElementNS(SVG_NS, 'rect');
      rect.setAttribute('x', el.x); rect.setAttribute('y', el.y);
      rect.setAttribute('width', el.width); rect.setAttribute('height', el.height);
      rect.setAttribute('rx', isSymbol ? 2 : 6);
      rect.setAttribute('fill', isSymbol ? 'var(--bg)' : (el.fill || this._themeBg2()));
      rect.setAttribute('stroke', isSymbol ? 'none' : (el.stroke || this._themeAccent()));
      rect.setAttribute('stroke-width', isSymbol ? 0 : (el.strokeWidth || 2));
      if (!isSymbol && el.strokeDasharray) rect.setAttribute('stroke-dasharray', el.strokeDasharray);
      group.appendChild(rect);
      if (isSymbol && el.symbolPath) {
        const pad = 8, labelH = el.text ? 20 : 0;
        const availW = el.width - pad * 2, availH = el.height - pad * 2 - labelH;
        const baseScale = Math.min(availW / 24, availH / 24);
        const scale = baseScale * (el.iconScale || 1);
        const ox = el.x + (el.width - 24 * scale) / 2;
        const oy = el.y + pad + (availH - 24 * scale) / 2;
        const sg = document.createElementNS(SVG_NS, 'g');
        sg.setAttribute('transform', `translate(${ox},${oy}) scale(${scale})`);
        const sp = document.createElementNS(SVG_NS, 'path');
        sp.setAttribute('d', el.symbolPath);
        sp.setAttribute('fill', el.symbolFill || 'none');
        sp.setAttribute('stroke', el.stroke || this._themeAccent());
        sp.setAttribute('stroke-width', Math.max(1, 1.5 / scale));
        sp.setAttribute('stroke-linecap', 'round'); sp.setAttribute('stroke-linejoin', 'round');
        if (el.symbolDash) sp.setAttribute('stroke-dasharray', el.symbolDash);
        sg.appendChild(sp);
        if (el.symbolCircle) { const c = document.createElementNS(SVG_NS, 'circle'); c.setAttribute('cx','12'); c.setAttribute('cy','12'); c.setAttribute('r','10'); c.setAttribute('fill','none'); c.setAttribute('stroke', el.stroke||'#f59e0b'); c.setAttribute('stroke-width', Math.max(1,1.5/scale)); sg.appendChild(c); }
        if (el.symbolExtra) { const ep = document.createElementNS(SVG_NS, 'path'); ep.setAttribute('d', el.symbolExtra); ep.setAttribute('fill','none'); ep.setAttribute('stroke', el.stroke||'#f59e0b'); ep.setAttribute('stroke-width', Math.max(1,1.5/scale)); ep.setAttribute('stroke-linecap','round'); sg.appendChild(ep); }
        if (el.symbolLabel) { const lt = document.createElementNS(SVG_NS, 'text'); lt.setAttribute('x','12'); lt.setAttribute('y','14'); lt.setAttribute('text-anchor','middle'); lt.setAttribute('font-size','6'); lt.setAttribute('fill', el.stroke||'#f59e0b'); lt.setAttribute('stroke','none'); lt.textContent = el.symbolLabel; sg.appendChild(lt); }
        group.appendChild(sg);
      }
    } else if (el.type === 'ellipse') {
      const ell = document.createElementNS(SVG_NS, 'ellipse');
      ell.setAttribute('cx', el.x + el.width / 2); ell.setAttribute('cy', el.y + el.height / 2);
      ell.setAttribute('rx', el.width / 2); ell.setAttribute('ry', el.height / 2);
      ell.setAttribute('fill', el.fill || this._themeBg2());
      ell.setAttribute('stroke', el.stroke || this._themeAccent());
      ell.setAttribute('stroke-width', el.strokeWidth || 2);
      if (el.strokeDasharray) ell.setAttribute('stroke-dasharray', el.strokeDasharray);
      group.appendChild(ell);
    }
    if (el.text) {
      const fo = document.createElementNS(SVG_NS, 'foreignObject');
      fo.setAttribute('x', el.x + 4); fo.setAttribute('y', el.y + 4);
      fo.setAttribute('width', el.width - 8); fo.setAttribute('height', el.height - 8);
      const div = document.createElement('div');
      div.style.cssText = `width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:${el.fontSize || 14}px;color:${el.type === 'sticky' ? '#1a1a1a' : 'var(--fg)'};overflow:hidden;word-break:break-word;line-height:1.3;white-space:pre-wrap;padding:4px;`;
      div.textContent = el.text;
      fo.appendChild(div);
      group.appendChild(fo);
    }
    container.appendChild(group);
  },
};

// ─── Keyup handler ──────────────────────────────────────
window.addEventListener('keyup', (e) => {
  if (e.key === ' ') {
    app._spaceDown = false;
    app._panStart = null;
    document.getElementById('canvas-wrap').style.cursor = app.tool === 'pan' ? 'grab' : app.tool === 'pen' ? 'crosshair' : 'default';
  }
});

// ─── Boot ───────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', () => app.init());

// ─── Service Worker registration (PWA) ─────────────────
if ('serviceWorker' in navigator) {
  // Inline SW via blob
  const swCode = `self.addEventListener('install',e=>{e.waitUntil(caches.open('forgeboard-v1').then(c=>c.addAll(['./','/'])));self.skipWaiting()});self.addEventListener('fetch',e=>{e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)))});`;
  const blob = new Blob([swCode], { type: 'application/javascript' });
  navigator.serviceWorker.register(URL.createObjectURL(blob)).catch(() => {});
}
</script>
</body>
</html>
